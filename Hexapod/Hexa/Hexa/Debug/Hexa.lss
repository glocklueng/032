
Hexa.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000017fe  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80003a00  80003a00  00003e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000118  80003c00  80003c00  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         0000003c  00000008  80003d18  00004408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000044  80003d54  00004444  2**0
                  ALLOC
  8 .bss          000000f8  00000048  00000048  00000000  2**2
                  ALLOC
  9 .heap         00002ec0  00000140  00000140  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00004444  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000620  00000000  00000000  00004478  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000129c  00000000  00000000  00004a98  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0000b484  00000000  00000000  00005d34  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00001791  00000000  00000000  000111b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000968b  00000000  00000000  00012949  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000fe8  00000000  00000000  0001bfd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000031d4  00000000  00000000  0001cfbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000381e  00000000  00000000  00020190  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00558b1a  00000000  00000000  000239ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00003000  00003000  00000000  2**0
                  ALLOC
 21 .debug_ranges 000029d8  00000000  00000000  0057c4c8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf f7 a4 	sub	pc,pc,-2140

Disassembly of section .text:

80002004 <flashcdw_default_wait_until_ready>:
80002004:	fe 6a 00 00 	mov	r10,-131072
}


void flashcdw_default_wait_until_ready(void)
{
	while (!flashcdw_is_ready());
80002008:	30 09       	mov	r9,0
//! @{


bool flashcdw_is_ready(void)
{
	return ((AVR32_FLASHCDW.fsr & AVR32_FLASHCDW_FSR_FRDY_MASK) != 0);
8000200a:	74 28       	ld.w	r8,r10[0x8]
}


void flashcdw_default_wait_until_ready(void)
{
	while (!flashcdw_is_ready());
8000200c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002010:	f2 08 18 00 	cp.b	r8,r9
80002014:	cf b0       	breq	8000200a <flashcdw_default_wait_until_ready+0x6>
}
80002016:	5e fc       	retal	r12

80002018 <flashcdw_set_flash_waitstate_and_readmode>:
	AVR32_FLASHCDW.fcr = u_avr32_flashcdw_fcr.fcr;
}


void flashcdw_set_flash_waitstate_and_readmode(unsigned long cpu_f_hz)
{
80002018:	eb cd 40 c0 	pushm	r6-r7,lr
	if (cpu_f_hz > AVR32_FLASHCDW_FWS_0_MAX_FREQ) { // > 15MHz
8000201c:	e0 68 e1 c0 	mov	r8,57792
80002020:	ea 18 00 e4 	orh	r8,0xe4
80002024:	10 3c       	cp.w	r12,r8
80002026:	e0 88 00 31 	brls	80002088 <flashcdw_set_flash_waitstate_and_readmode+0x70>
		if (cpu_f_hz <= AVR32_FLASHCDW_FWS_1_MAX_FREQ) { // <= 30MHz
8000202a:	e0 68 c3 80 	mov	r8,50048
8000202e:	ea 18 01 c9 	orh	r8,0x1c9
80002032:	10 3c       	cp.w	r12,r8
80002034:	e0 8b 00 0f 	brhi	80002052 <flashcdw_set_flash_waitstate_and_readmode+0x3a>
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
80002038:	fe 67 00 00 	mov	r7,-131072

void flashcdw_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
8000203c:	30 86       	mov	r6,8
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
8000203e:	6e 08       	ld.w	r8,r7[0x0]
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
80002040:	30 19       	mov	r9,1
80002042:	f1 d9 d0 c1 	bfins	r8,r9,0x6,0x1
	AVR32_FLASHCDW.fcr = u_avr32_flashcdw_fcr.fcr;
80002046:	8f 08       	st.w	r7[0x0],r8

void flashcdw_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
80002048:	6c 08       	ld.w	r8,r6[0x0]
8000204a:	5d 18       	icall	r8
	u_avr32_flashcdw_fcmd.fcmd = AVR32_FLASHCDW.fcmd;
8000204c:	6e 18       	ld.w	r8,r7[0x4]
	u_avr32_flashcdw_fcmd.FCMD.cmd = command;
8000204e:	31 19       	mov	r9,17
80002050:	c0 d8       	rjmp	8000206a <flashcdw_set_flash_waitstate_and_readmode+0x52>
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
80002052:	fe 67 00 00 	mov	r7,-131072
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
80002056:	30 19       	mov	r9,1
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
80002058:	6e 08       	ld.w	r8,r7[0x0]
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
8000205a:	f1 d9 d0 c1 	bfins	r8,r9,0x6,0x1

void flashcdw_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
8000205e:	30 86       	mov	r6,8

void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
	AVR32_FLASHCDW.fcr = u_avr32_flashcdw_fcr.fcr;
80002060:	8f 08       	st.w	r7[0x0],r8

void flashcdw_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
80002062:	6c 08       	ld.w	r8,r6[0x0]
80002064:	5d 18       	icall	r8
	u_avr32_flashcdw_fcmd.fcmd = AVR32_FLASHCDW.fcmd;
80002066:	6e 18       	ld.w	r8,r7[0x4]
	u_avr32_flashcdw_fcmd.FCMD.cmd = command;
80002068:	31 09       	mov	r9,16
8000206a:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
	if (page_number >= 0) {
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
8000206e:	3a 59       	mov	r9,-91
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
	flashcdw_error_status = flashcdw_get_error_status();
80002070:	34 8a       	mov	r10,72
	u_avr32_flashcdw_fcmd.fcmd = AVR32_FLASHCDW.fcmd;
	u_avr32_flashcdw_fcmd.FCMD.cmd = command;
	if (page_number >= 0) {
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
80002072:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
80002076:	8f 18       	st.w	r7[0x4],r8
 *          the driver's API which instead presents \ref flashcdw_is_lock_error
 *          and \ref flashcdw_is_programming_error.
 */
static unsigned int flashcdw_get_error_status(void)
{
	return AVR32_FLASHCDW.fsr & (AVR32_FLASHCDW_FSR_LOCKE_MASK |
80002078:	6e 29       	ld.w	r9,r7[0x8]
	if (page_number >= 0) {
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
	flashcdw_error_status = flashcdw_get_error_status();
8000207a:	e2 19 00 0c 	andl	r9,0xc,COH
	flashcdw_wait_until_ready();
8000207e:	6c 08       	ld.w	r8,r6[0x0]
	if (page_number >= 0) {
		u_avr32_flashcdw_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashcdw_fcmd.FCMD.key = AVR32_FLASHCDW_FCMD_KEY_KEY;
	AVR32_FLASHCDW.fcmd = u_avr32_flashcdw_fcmd.fcmd;
	flashcdw_error_status = flashcdw_get_error_status();
80002080:	95 09       	st.w	r10[0x0],r9
	flashcdw_wait_until_ready();
80002082:	5d 18       	icall	r8
80002084:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
80002088:	fe 67 00 00 	mov	r7,-131072

void flashcdw_issue_command(unsigned int command, int page_number)
{
	u_avr32_flashcdw_fcmd_t u_avr32_flashcdw_fcmd;

	flashcdw_wait_until_ready();
8000208c:	30 86       	mov	r6,8
}


void flashcdw_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashcdw_fcr_t u_avr32_flashcdw_fcr = {AVR32_FLASHCDW.fcr};
8000208e:	6e 08       	ld.w	r8,r7[0x0]
	u_avr32_flashcdw_fcr.FCR.fws = wait_state;
80002090:	30 09       	mov	r9,0
80002092:	cd 8b       	rjmp	80002042 <flashcdw_set_flash_waitstate_and_readmode+0x2a>

80002094 <gpio_enable_module_pin>:
}


int gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002094:	f8 08 16 05 	lsr	r8,r12,0x5
80002098:	a9 78       	lsl	r8,0x9
8000209a:	e0 28 d4 00 	sub	r8,54272

  // Enable the correct function.
  switch (function)
8000209e:	58 7b       	cp.w	r11,7
800020a0:	e0 88 00 03 	brls	800020a6 <gpio_enable_module_pin+0x12>
800020a4:	5e ff       	retal	1
800020a6:	fe c9 e4 a6 	sub	r9,pc,-7002
800020aa:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
    gpio_port->pmr1c = 1 << (pin & 0x1F);
    gpio_port->pmr2s = 1 << (pin & 0x1F);
    break;

  case 6: // G function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020ae:	30 19       	mov	r9,1
800020b0:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020b4:	91 6c       	st.w	r8[0x18],r12
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020b6:	91 9c       	st.w	r8[0x24],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020b8:	91 dc       	st.w	r8[0x34],r12
800020ba:	91 2c       	st.w	r8[0x8],r12
    gpio_port->pmr1s = 1 << (pin & 0x1F);
    gpio_port->pmr2s = 1 << (pin & 0x1F);
    break;

  case 7: // H function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020bc:	5e fd       	retal	0
800020be:	30 19       	mov	r9,1
800020c0:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020c4:	91 5c       	st.w	r8[0x14],r12
    gpio_port->pmr2s = 1 << (pin & 0x1F);
800020c6:	91 9c       	st.w	r8[0x24],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020c8:	91 dc       	st.w	r8[0x34],r12
800020ca:	91 2c       	st.w	r8[0x8],r12

  // Enable the correct function.
  switch (function)
  {
  case 0: // A function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020cc:	5e fd       	retal	0
800020ce:	30 19       	mov	r9,1
800020d0:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1c = 1 << (pin & 0x1F);
800020d4:	91 6c       	st.w	r8[0x18],r12
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020d6:	91 ac       	st.w	r8[0x28],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020d8:	91 ec       	st.w	r8[0x38],r12
800020da:	91 2c       	st.w	r8[0x8],r12
    gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
    break;

  case 1: // B function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020dc:	5e fd       	retal	0
800020de:	30 19       	mov	r9,1
800020e0:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1c = 1 << (pin & 0x1F);
800020e4:	91 5c       	st.w	r8[0x14],r12
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020e6:	91 ac       	st.w	r8[0x28],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020e8:	91 ec       	st.w	r8[0x38],r12
800020ea:	91 2c       	st.w	r8[0x8],r12
    gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
    break;

  case 2: // C function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
800020ec:	5e fd       	retal	0
800020ee:	30 19       	mov	r9,1
800020f0:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1s = 1 << (pin & 0x1F);
800020f4:	91 6c       	st.w	r8[0x18],r12
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
800020f6:	91 9c       	st.w	r8[0x24],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
800020f8:	91 ec       	st.w	r8[0x38],r12
800020fa:	91 2c       	st.w	r8[0x8],r12
    gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
    break;

  case 3: // D function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
800020fc:	5e fd       	retal	0
800020fe:	30 19       	mov	r9,1
80002100:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1s = 1 << (pin & 0x1F);
80002104:	91 5c       	st.w	r8[0x14],r12
#if (AVR32_GPIO_H_VERSION >= 210)
    gpio_port->pmr2c = 1 << (pin & 0x1F);
80002106:	91 9c       	st.w	r8[0x24],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
80002108:	91 ec       	st.w	r8[0x38],r12
8000210a:	91 2c       	st.w	r8[0x8],r12
#endif
    break;

#if (AVR32_GPIO_H_VERSION >= 210)
  case 4: // E function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
8000210c:	5e fd       	retal	0
8000210e:	30 19       	mov	r9,1
80002110:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80002114:	91 6c       	st.w	r8[0x18],r12
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002116:	91 ac       	st.w	r8[0x28],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
80002118:	91 dc       	st.w	r8[0x34],r12
8000211a:	91 2c       	st.w	r8[0x8],r12
    gpio_port->pmr1c = 1 << (pin & 0x1F);
    gpio_port->pmr2s = 1 << (pin & 0x1F);
    break;

  case 5: // F function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
8000211c:	5e fd       	retal	0
8000211e:	30 19       	mov	r9,1
80002120:	f2 0c 09 4c 	lsl	r12,r9,r12
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80002124:	91 5c       	st.w	r8[0x14],r12
    gpio_port->pmr2s = 1 << (pin & 0x1F);
80002126:	91 ac       	st.w	r8[0x28],r12
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
80002128:	91 dc       	st.w	r8[0x34],r12
8000212a:	91 2c       	st.w	r8[0x8],r12
8000212c:	5e fd       	retal	0
8000212e:	d7 03       	nop

80002130 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002130:	e0 68 00 83 	mov	r8,131
80002134:	f0 0c 01 0c 	sub	r12,r8,r12
80002138:	fe 78 10 00 	mov	r8,-61440
8000213c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002140:	f2 ca ff c0 	sub	r10,r9,-64
80002144:	f0 0a 03 2c 	ld.w	r12,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002148:	58 0c       	cp.w	r12,0
8000214a:	5e 0c       	reteq	r12
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000214c:	fe c8 e5 2c 	sub	r8,pc,-6868
80002150:	f8 0c 12 00 	clz	r12,r12
80002154:	f0 09 00 39 	add	r9,r8,r9<<0x3
80002158:	f8 0c 11 1f 	rsub	r12,r12,31
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000215c:	72 18       	ld.w	r8,r9[0x4]
8000215e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002162:	5e fc       	retal	r12

80002164 <pm_set_mclk_source>:
 ** Clock Functions
 **/

long pm_set_mclk_source(pm_clk_src_t src)
{
  AVR32_ENTER_CRITICAL_REGION( );
80002164:	e1 b8 00 00 	mfsr	r8,0x0
80002168:	d3 03       	ssrf	0x10
  // Unlock the write-protected MCCTRL register
  PM_UNLOCK(AVR32_PM_MCCTRL);
8000216a:	fe 79 14 00 	mov	r9,-60416
8000216e:	fc 1a aa 00 	movh	r10,0xaa00
80002172:	f3 4a 00 58 	st.w	r9[88],r10
  AVR32_PM.mcctrl = src;
80002176:	93 0c       	st.w	r9[0x0],r12
  AVR32_LEAVE_CRITICAL_REGION( );
80002178:	ed b8 00 10 	bld	r8,0x10
8000217c:	c0 20       	breq	80002180 <pm_set_mclk_source+0x1c>
8000217e:	d5 03       	csrf	0x10

  return PASS;
}
80002180:	5e fd       	retal	0

80002182 <pm_set_all_cksel>:
  return PASS;
}

void pm_set_all_cksel(unsigned long main_clock_f_hz, unsigned long cpu_f_hz,
                      unsigned long pba_f_hz, unsigned long pbb_f_hz)
{
80002182:	eb cd 40 c0 	pushm	r6-r7,lr
 */
static pm_divratio_t pm_find_divratio(unsigned long ref_freq_hz, unsigned long target_freq_hz)
{
  int div_ratio;

  div_ratio = ref_freq_hz/target_freq_hz;
80002186:	f8 0b 0d 06 	divu	r6,r12,r11
8000218a:	0c 98       	mov	r8,r6
  if(div_ratio == 1)
8000218c:	58 16       	cp.w	r6,1
8000218e:	e0 80 00 cf 	breq	8000232c <pm_set_all_cksel+0x1aa>
    return(PM_CKSEL_DIVRATIO_ERROR);
  else
  {
    // div ratio field value so that rel_freq_hz = target_freq_hz*2pow(divratio+1)
    return((pm_divratio_t)(ctz(div_ratio)-1));
80002192:	5c 98       	brev	r8
80002194:	f0 08 12 00 	clz	r8,r8
80002198:	f0 c7 00 01 	sub	r7,r8,1


  // Find the divratio to apply to reach the target cpu_f frequency.
  div_ratio = pm_find_divratio(main_clock_f_hz, cpu_f_hz);
  // Apply the division ratio for the CPU clock domain.
  if(PM_CKSEL_DIVRATIO_ERROR == div_ratio)
8000219c:	58 87       	cp.w	r7,8
8000219e:	e0 80 00 c7 	breq	8000232c <pm_set_all_cksel+0x1aa>
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800021a2:	fe 78 14 00 	mov	r8,-60416
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800021a6:	10 9b       	mov	r11,r8
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800021a8:	70 1e       	ld.w	lr,r8[0x4]
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800021aa:	f6 f8 00 d4 	ld.w	r8,r11[212]
800021ae:	ed b8 00 05 	bld	r8,0x5
800021b2:	cf c1       	brne	800021aa <pm_set_all_cksel+0x28>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
800021b4:	30 18       	mov	r8,1
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800021b6:	1c 9b       	mov	r11,lr

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
800021b8:	f7 d8 d0 e1 	bfins	r11,r8,0x7,0x1
  u_avr32_pm_cpusel.CPUSEL.cpusel = divratio;
800021bc:	f7 d7 d0 03 	bfins	r11,r7,0x0,0x3
  AVR32_ENTER_CRITICAL_REGION( );
800021c0:	e1 b8 00 00 	mfsr	r8,0x0
800021c4:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
800021c6:	fe 77 14 00 	mov	r7,-60416
800021ca:	30 4e       	mov	lr,4
800021cc:	ea 1e aa 00 	orh	lr,0xaa00
800021d0:	ef 4e 00 58 	st.w	r7[88],lr
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
800021d4:	fe 77 14 04 	mov	r7,-60412
800021d8:	8f 0b       	st.w	r7[0x0],r11
  AVR32_LEAVE_CRITICAL_REGION( );
800021da:	ed b8 00 10 	bld	r8,0x10
800021de:	e0 81 00 82 	brne	800022e2 <pm_set_all_cksel+0x160>
 */
static pm_divratio_t pm_find_divratio(unsigned long ref_freq_hz, unsigned long target_freq_hz)
{
  int div_ratio;

  div_ratio = ref_freq_hz/target_freq_hz;
800021e2:	f8 0a 0d 0a 	divu	r10,r12,r10
800021e6:	14 98       	mov	r8,r10
  if(div_ratio == 1)
800021e8:	58 1a       	cp.w	r10,1
800021ea:	e0 80 00 82 	breq	800022ee <pm_set_all_cksel+0x16c>
    return(PM_CKSEL_DIVRATIO_ERROR);
  else
  {
    // div ratio field value so that rel_freq_hz = target_freq_hz*2pow(divratio+1)
    return((pm_divratio_t)(ctz(div_ratio)-1));
800021ee:	5c 98       	brev	r8
800021f0:	f0 08 12 00 	clz	r8,r8
800021f4:	f0 cb 00 01 	sub	r11,r8,1
    pm_set_clk_domain_div((pm_clk_domain_t)AVR32_PM_CLK_GRP_CPU, div_ratio);

  // Find the divratio to apply to reach the target pba_f frequency.
  div_ratio = pm_find_divratio(main_clock_f_hz, pba_f_hz);
  // Apply the division ratio for the PBA clock domain.
  if(PM_CKSEL_DIVRATIO_ERROR == div_ratio)
800021f8:	58 8b       	cp.w	r11,8
800021fa:	c7 a0       	breq	800022ee <pm_set_all_cksel+0x16c>
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800021fc:	fe 78 14 00 	mov	r8,-60416
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002200:	10 9a       	mov	r10,r8
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002202:	70 17       	ld.w	r7,r8[0x4]
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002204:	f4 f8 00 d4 	ld.w	r8,r10[212]
80002208:	ed b8 00 05 	bld	r8,0x5
8000220c:	cf c1       	brne	80002204 <pm_set_all_cksel+0x82>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
8000220e:	30 18       	mov	r8,1
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002210:	0e 9a       	mov	r10,r7

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
80002212:	f5 d8 d0 e1 	bfins	r10,r8,0x7,0x1
  u_avr32_pm_cpusel.CPUSEL.cpusel = divratio;
80002216:	f5 db d0 03 	bfins	r10,r11,0x0,0x3
  AVR32_ENTER_CRITICAL_REGION( );
8000221a:	e1 b8 00 00 	mfsr	r8,0x0
8000221e:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
80002220:	fe 7b 14 00 	mov	r11,-60416
80002224:	30 c7       	mov	r7,12
80002226:	ea 17 aa 00 	orh	r7,0xaa00
8000222a:	f7 47 00 58 	st.w	r11[88],r7
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
8000222e:	fe 7b 14 0c 	mov	r11,-60404
80002232:	97 0a       	st.w	r11[0x0],r10
  AVR32_LEAVE_CRITICAL_REGION( );
80002234:	ed b8 00 10 	bld	r8,0x10
80002238:	c3 01       	brne	80002298 <pm_set_all_cksel+0x116>
 */
static pm_divratio_t pm_find_divratio(unsigned long ref_freq_hz, unsigned long target_freq_hz)
{
  int div_ratio;

  div_ratio = ref_freq_hz/target_freq_hz;
8000223a:	f8 09 0d 08 	divu	r8,r12,r9
  if(div_ratio == 1)
8000223e:	58 18       	cp.w	r8,1
80002240:	c3 10       	breq	800022a2 <pm_set_all_cksel+0x120>
    return(PM_CKSEL_DIVRATIO_ERROR);
  else
  {
    // div ratio field value so that rel_freq_hz = target_freq_hz*2pow(divratio+1)
    return((pm_divratio_t)(ctz(div_ratio)-1));
80002242:	5c 98       	brev	r8
80002244:	f0 08 12 00 	clz	r8,r8
80002248:	f0 ca 00 01 	sub	r10,r8,1
    pm_set_clk_domain_div((pm_clk_domain_t)AVR32_PM_CLK_GRP_PBA, div_ratio);

  // Find the divratio to apply to reach the target pbb_f frequency.
  div_ratio = pm_find_divratio(main_clock_f_hz, pbb_f_hz);
  // Apply the division ratio for the PBB clock domain.
  if(PM_CKSEL_DIVRATIO_ERROR == div_ratio)
8000224c:	58 8a       	cp.w	r10,8
8000224e:	c2 a0       	breq	800022a2 <pm_set_all_cksel+0x120>
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002250:	fe 78 14 00 	mov	r8,-60416
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002254:	10 99       	mov	r9,r8
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002256:	70 1b       	ld.w	r11,r8[0x4]
  if((divratio > PM_CPUSEL_DIVRATIO_MAX)||(divratio < 0))
    return -1;
#endif

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002258:	f2 f8 00 d4 	ld.w	r8,r9[212]
8000225c:	ed b8 00 05 	bld	r8,0x5
80002260:	cf c1       	brne	80002258 <pm_set_all_cksel+0xd6>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
80002262:	30 18       	mov	r8,1
  return PASS;
}

long pm_set_clk_domain_div(pm_clk_domain_t clock_domain, pm_divratio_t divratio)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002264:	16 99       	mov	r9,r11

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= 1;
80002266:	f3 d8 d0 e1 	bfins	r9,r8,0x7,0x1
  u_avr32_pm_cpusel.CPUSEL.cpusel = divratio;
8000226a:	f3 da d0 03 	bfins	r9,r10,0x0,0x3
  AVR32_ENTER_CRITICAL_REGION( );
8000226e:	e1 b8 00 00 	mfsr	r8,0x0
80002272:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
80002274:	fe 7a 14 00 	mov	r10,-60416
80002278:	31 0b       	mov	r11,16
8000227a:	ea 1b aa 00 	orh	r11,0xaa00
8000227e:	f5 4b 00 58 	st.w	r10[88],r11
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
80002282:	fe 7a 14 10 	mov	r10,-60400
80002286:	95 09       	st.w	r10[0x0],r9
  AVR32_LEAVE_CRITICAL_REGION( );
80002288:	ed b8 00 10 	bld	r8,0x10
8000228c:	c0 31       	brne	80002292 <pm_set_all_cksel+0x110>
8000228e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002292:	d5 03       	csrf	0x10
80002294:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002298:	d5 03       	csrf	0x10
 */
static pm_divratio_t pm_find_divratio(unsigned long ref_freq_hz, unsigned long target_freq_hz)
{
  int div_ratio;

  div_ratio = ref_freq_hz/target_freq_hz;
8000229a:	f8 09 0d 08 	divu	r8,r12,r9
  if(div_ratio == 1)
8000229e:	58 18       	cp.w	r8,1
800022a0:	cd 11       	brne	80002242 <pm_set_all_cksel+0xc0>
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800022a2:	fe 78 14 00 	mov	r8,-60416

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800022a6:	10 99       	mov	r9,r8
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800022a8:	70 1a       	ld.w	r10,r8[0x4]

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800022aa:	f2 f8 00 d4 	ld.w	r8,r9[212]
800022ae:	ed b8 00 05 	bld	r8,0x5
800022b2:	cf c1       	brne	800022aa <pm_set_all_cksel+0x128>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
800022b4:	30 08       	mov	r8,0
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800022b6:	14 99       	mov	r9,r10

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
800022b8:	f3 d8 d0 e1 	bfins	r9,r8,0x7,0x1
  AVR32_ENTER_CRITICAL_REGION( );
800022bc:	e1 b8 00 00 	mfsr	r8,0x0
800022c0:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
800022c2:	fe 7a 14 00 	mov	r10,-60416
800022c6:	31 0b       	mov	r11,16
800022c8:	ea 1b aa 00 	orh	r11,0xaa00
800022cc:	f5 4b 00 58 	st.w	r10[88],r11
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
800022d0:	fe 7a 14 10 	mov	r10,-60400
800022d4:	95 09       	st.w	r10[0x0],r9
  AVR32_LEAVE_CRITICAL_REGION( );
800022d6:	ed b8 00 10 	bld	r8,0x10
800022da:	cd a0       	breq	8000228e <pm_set_all_cksel+0x10c>
800022dc:	d5 03       	csrf	0x10
800022de:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  AVR32_ENTER_CRITICAL_REGION( );
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
  AVR32_LEAVE_CRITICAL_REGION( );
800022e2:	d5 03       	csrf	0x10
 */
static pm_divratio_t pm_find_divratio(unsigned long ref_freq_hz, unsigned long target_freq_hz)
{
  int div_ratio;

  div_ratio = ref_freq_hz/target_freq_hz;
800022e4:	f8 0a 0d 0a 	divu	r10,r12,r10
800022e8:	14 98       	mov	r8,r10
  if(div_ratio == 1)
800022ea:	58 1a       	cp.w	r10,1
800022ec:	c8 11       	brne	800021ee <pm_set_all_cksel+0x6c>
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800022ee:	fe 78 14 00 	mov	r8,-60416

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800022f2:	10 9a       	mov	r10,r8
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
800022f4:	70 1b       	ld.w	r11,r8[0x4]

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
800022f6:	f4 f8 00 d4 	ld.w	r8,r10[212]
800022fa:	ed b8 00 05 	bld	r8,0x5
800022fe:	cf c1       	brne	800022f6 <pm_set_all_cksel+0x174>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
80002300:	30 08       	mov	r8,0
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002302:	16 9a       	mov	r10,r11

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
80002304:	f5 d8 d0 e1 	bfins	r10,r8,0x7,0x1
  AVR32_ENTER_CRITICAL_REGION( );
80002308:	e1 b8 00 00 	mfsr	r8,0x0
8000230c:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
8000230e:	fe 7b 14 00 	mov	r11,-60416
80002312:	30 ce       	mov	lr,12
80002314:	ea 1e aa 00 	orh	lr,0xaa00
80002318:	f7 4e 00 58 	st.w	r11[88],lr
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
8000231c:	fe 7b 14 0c 	mov	r11,-60404
80002320:	97 0a       	st.w	r11[0x0],r10
  AVR32_LEAVE_CRITICAL_REGION( );
80002322:	ed b8 00 10 	bld	r8,0x10
80002326:	c8 a0       	breq	8000223a <pm_set_all_cksel+0xb8>
80002328:	d5 03       	csrf	0x10
8000232a:	c8 8b       	rjmp	8000223a <pm_set_all_cksel+0xb8>
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
8000232c:	fe 78 14 00 	mov	r8,-60416

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002330:	10 9b       	mov	r11,r8
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002332:	70 1e       	ld.w	lr,r8[0x4]

//# Implementation note: the ckSEL registers are contiguous and memory-mapped in
//# that order: CPUSEL, HSBSEL, PBASEL, PBBSEL.

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));
80002334:	f6 f8 00 d4 	ld.w	r8,r11[212]
80002338:	ed b8 00 05 	bld	r8,0x5
8000233c:	cf c1       	brne	80002334 <pm_set_all_cksel+0x1b2>

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
8000233e:	30 08       	mov	r8,0
  return PASS;
}

long pm_disable_clk_domain_div(pm_clk_domain_t clock_domain)
{
  u_avr32_pm_cpusel_t u_avr32_pm_cpusel = {AVR32_PM.cpusel};
80002340:	1c 9b       	mov	r11,lr

  // ckSEL must not be written while SR.CKRDY is 0.
  while(!(AVR32_PM.sr & AVR32_PM_SR_CKRDY_MASK));

  // Modify
  u_avr32_pm_cpusel.CPUSEL.cpudiv= DISABLE;
80002342:	f7 d8 d0 e1 	bfins	r11,r8,0x7,0x1
  AVR32_ENTER_CRITICAL_REGION( );
80002346:	e1 b8 00 00 	mfsr	r8,0x0
8000234a:	d3 03       	ssrf	0x10
  // Unlock the write-protected ckSEL register
  PM_UNLOCK(AVR32_PM_CPUSEL + clock_domain*sizeof(avr32_pm_cpusel_t));
8000234c:	fe 7e 14 00 	mov	lr,-60416
80002350:	30 47       	mov	r7,4
80002352:	ea 17 aa 00 	orh	r7,0xaa00
80002356:	fd 47 00 58 	st.w	lr[88],r7
  // Update
  *(&(AVR32_PM.cpusel) + clock_domain)= u_avr32_pm_cpusel.cpusel;
8000235a:	fe 7e 14 04 	mov	lr,-60412
8000235e:	9d 0b       	st.w	lr[0x0],r11
  AVR32_LEAVE_CRITICAL_REGION( );
80002360:	ed b8 00 10 	bld	r8,0x10
80002364:	fe 90 ff 3f 	breq	800021e2 <pm_set_all_cksel+0x60>
80002368:	d5 03       	csrf	0x10
8000236a:	c3 cb       	rjmp	800021e2 <pm_set_all_cksel+0x60>

8000236c <pcl_configure_clocks_rc120m>:
  return(pcl_configure_synchronous_clocks(PM_CLK_SRC_SLOW, SCIF_SLOWCLOCK_FREQ_HZ, param));
}


long int pcl_configure_clocks_rc120m(pcl_freq_param_t *param)
{
8000236c:	eb cd 40 80 	pushm	r7,lr
80002370:	18 97       	mov	r7,r12
    || (param->pbb_f > SCIF_RC120M_FREQ_HZ))
    return(-1);
#endif

  // Start the 120MHz internal RCosc (RC120M) clock
  scif_start_rc120M();
80002372:	ce 5c       	rcall	8000253c <scif_start_rc120M>
80002374:	6e 39       	ld.w	r9,r7[0xc]
static long int pcl_configure_synchronous_clocks(pm_clk_src_t main_clk_src, unsigned long main_clock_freq_hz, pcl_freq_param_t *param)
{
  //#
  //# Set the Synchronous clock division ratio for each clock domain
  //#
  pm_set_all_cksel(main_clock_freq_hz, param->cpu_f, param->pba_f, param->pbb_f);
80002376:	6e 2a       	ld.w	r10,r7[0x8]
80002378:	6e 1b       	ld.w	r11,r7[0x4]
8000237a:	e0 6c 0e 00 	mov	r12,3584
8000237e:	ea 1c 07 27 	orh	r12,0x727
80002382:	c0 0f       	rcall	80002182 <pm_set_all_cksel>
80002384:	6e 1c       	ld.w	r12,r7[0x4]
80002386:	c4 9e       	rcall	80002018 <flashcdw_set_flash_waitstate_and_readmode>

  //#
  //# Set the Flash wait state and the speed read mode (depending on the target CPU frequency).
  //#
#if UC3L
    flashcdw_set_flash_waitstate_and_readmode(param->cpu_f);
80002388:	30 3c       	mov	r12,3
8000238a:	ce de       	rcall	80002164 <pm_set_mclk_source>
8000238c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80002390 <pcl_configure_clocks_osc0>:


  //#
  //# Switch the main clock source to the selected clock.
  //#
  pm_set_mclk_source(main_clk_src);
80002390:	eb cd 40 c0 	pushm	r6-r7,lr

  // Start the 120MHz internal RCosc (RC120M) clock
  scif_start_rc120M();

  return(pcl_configure_synchronous_clocks(PM_CLK_SRC_RC120M, SCIF_RC120M_FREQ_HZ, param));
}
80002394:	18 97       	mov	r7,r12
80002396:	30 0c       	mov	r12,0
80002398:	6e 56       	ld.w	r6,r7[0x14]
8000239a:	0c 9b       	mov	r11,r6
8000239c:	e0 a0 02 30 	rcall	800027fc <scif_configure_osc_crystalmode>
800023a0:	6e 6b       	ld.w	r11,r7[0x18]
800023a2:	30 1a       	mov	r10,1
800023a4:	30 0c       	mov	r12,0
800023a6:	e0 a0 02 07 	rcall	800027b4 <scif_enable_osc>
static long int pcl_configure_synchronous_clocks(pm_clk_src_t main_clk_src, unsigned long main_clock_freq_hz, pcl_freq_param_t *param)
{
  //#
  //# Set the Synchronous clock division ratio for each clock domain
  //#
  pm_set_all_cksel(main_clock_freq_hz, param->cpu_f, param->pba_f, param->pbb_f);
800023aa:	6e 39       	ld.w	r9,r7[0xc]
800023ac:	6e 2a       	ld.w	r10,r7[0x8]
800023ae:	6e 1b       	ld.w	r11,r7[0x4]
800023b0:	0c 9c       	mov	r12,r6
800023b2:	ce 8e       	rcall	80002182 <pm_set_all_cksel>
800023b4:	6e 1c       	ld.w	r12,r7[0x4]

  //#
  //# Set the Flash wait state and the speed read mode (depending on the target CPU frequency).
  //#
#if UC3L
    flashcdw_set_flash_waitstate_and_readmode(param->cpu_f);
800023b6:	c3 1e       	rcall	80002018 <flashcdw_set_flash_waitstate_and_readmode>
800023b8:	30 1c       	mov	r12,1
800023ba:	cd 5e       	rcall	80002164 <pm_set_mclk_source>


  //#
  //# Switch the main clock source to the selected clock.
  //#
  pm_set_mclk_source(main_clk_src);
800023bc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0

800023c0 <pcl_configure_clocks>:
800023c0:	eb cd 40 c0 	pushm	r6-r7,lr
  scif_configure_osc_crystalmode(SCIF_OSC0, main_clock_freq);
  // Enable the OSC0
  scif_enable_osc(SCIF_OSC0, param->osc0_startup, true);

  return(pcl_configure_synchronous_clocks(PM_CLK_SRC_OSC0, main_clock_freq, param));
}
800023c4:	18 97       	mov	r7,r12
800023c6:	78 06       	ld.w	r6,r12[0x0]
800023c8:	58 06       	cp.w	r6,0
800023ca:	c1 60       	breq	800023f6 <pcl_configure_clocks+0x36>
800023cc:	58 96       	cp.w	r6,9
800023ce:	c2 40       	breq	80002416 <pcl_configure_clocks+0x56>
800023d0:	58 16       	cp.w	r6,1
800023d2:	c1 f0       	breq	80002410 <pcl_configure_clocks+0x50>
800023d4:	78 76       	ld.w	r6,r12[0x1c]
800023d6:	30 19       	mov	r9,1
800023d8:	0c 9a       	mov	r10,r6
800023da:	30 0b       	mov	r11,0
#endif
  pgc_dfllif_ref_opt = (scif_gclk_opt_t *)param->pextra_params;
  // Implementation note: this implementation configures the DFLL in closed-loop
  // mode (because it gives the best accuracy) which enables the generic clock CLK_DFLLIF_REF
  // as a reference (RCSYS being used as the generic clock source, undivided).
  scif_dfll0_closedloop_configure_and_start(pgc_dfllif_ref_opt, main_clock_freq, true);
800023dc:	78 8c       	ld.w	r12,r12[0x20]
800023de:	c5 3d       	rcall	80002684 <scif_dfll0_closedloop_configure_and_start>
800023e0:	6e 39       	ld.w	r9,r7[0xc]
static long int pcl_configure_synchronous_clocks(pm_clk_src_t main_clk_src, unsigned long main_clock_freq_hz, pcl_freq_param_t *param)
{
  //#
  //# Set the Synchronous clock division ratio for each clock domain
  //#
  pm_set_all_cksel(main_clock_freq_hz, param->cpu_f, param->pba_f, param->pbb_f);
800023e2:	6e 2a       	ld.w	r10,r7[0x8]
800023e4:	6e 1b       	ld.w	r11,r7[0x4]
800023e6:	0c 9c       	mov	r12,r6
800023e8:	cc de       	rcall	80002182 <pm_set_all_cksel>
800023ea:	6e 1c       	ld.w	r12,r7[0x4]
800023ec:	c1 6e       	rcall	80002018 <flashcdw_set_flash_waitstate_and_readmode>

  //#
  //# Set the Flash wait state and the speed read mode (depending on the target CPU frequency).
  //#
#if UC3L
    flashcdw_set_flash_waitstate_and_readmode(param->cpu_f);
800023ee:	30 2c       	mov	r12,2
800023f0:	cb ae       	rcall	80002164 <pm_set_mclk_source>
800023f2:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0


  //#
  //# Switch the main clock source to the selected clock.
  //#
  pm_set_mclk_source(main_clk_src);
800023f6:	78 39       	ld.w	r9,r12[0xc]
800023f8:	78 2a       	ld.w	r10,r12[0x8]
800023fa:	78 1b       	ld.w	r11,r12[0x4]
800023fc:	e0 7c c2 00 	mov	r12,115200
static long int pcl_configure_synchronous_clocks(pm_clk_src_t main_clk_src, unsigned long main_clock_freq_hz, pcl_freq_param_t *param)
{
  //#
  //# Set the Synchronous clock division ratio for each clock domain
  //#
  pm_set_all_cksel(main_clock_freq_hz, param->cpu_f, param->pba_f, param->pbb_f);
80002400:	cc 1e       	rcall	80002182 <pm_set_all_cksel>
80002402:	6e 1c       	ld.w	r12,r7[0x4]
80002404:	c0 ae       	rcall	80002018 <flashcdw_set_flash_waitstate_and_readmode>
80002406:	0c 9c       	mov	r12,r6
80002408:	ca ee       	rcall	80002164 <pm_set_mclk_source>
8000240a:	0c 9c       	mov	r12,r6

  //#
  //# Set the Flash wait state and the speed read mode (depending on the target CPU frequency).
  //#
#if UC3L
    flashcdw_set_flash_waitstate_and_readmode(param->cpu_f);
8000240c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002410:	cc 0f       	rcall	80002390 <pcl_configure_clocks_osc0>


  //#
  //# Switch the main clock source to the selected clock.
  //#
  pm_set_mclk_source(main_clk_src);
80002412:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002416:	ca bf       	rcall	8000236c <pcl_configure_clocks_rc120m>
80002418:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

8000241c <pwma_config_and_enable>:

void pwma_config_and_enable(volatile avr32_pwma_t *pwma,
                            unsigned long long int channel_mask,
                            int period_cycles, int duty_cycles)
{
  pwma->cr =
8000241c:	a9 69       	lsl	r9,0x8
8000241e:	e8 19 00 03 	orl	r9,0x3
80002422:	99 09       	st.w	r12[0x0],r9
  //# to allow multiple channels to be updated simultaneously with the same duty
  //# cycle
  //#

  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
80002424:	78 79       	ld.w	r9,r12[0x1c]
80002426:	ed b9 00 03 	bld	r9,0x3
8000242a:	cf d0       	breq	80002424 <pwma_config_and_enable+0x8>

  //#
  //# First 32 channels
  //#
  // Set the common duty cycle value.
  pwma->isduty = duty_cycles;
8000242c:	99 18       	st.w	r12[0x4],r8
  // Define the interlinked channels
#if (UC3D)
  pwma->chgroup[0].ischset = channel_mask_low;
#else
  pwma->ischset0 = channel_mask_low;
8000242e:	99 ca       	st.w	r12[0x30],r10
#endif

  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
80002430:	78 79       	ld.w	r9,r12[0x1c]
80002432:	ed b9 00 03 	bld	r9,0x3
80002436:	cf d0       	breq	80002430 <pwma_config_and_enable+0x14>

  //#
  //# Last 32 channels
  //#
  // Set the common duty cycle value.
  pwma->isduty = duty_cycles;
80002438:	99 18       	st.w	r12[0x4],r8
  // Define the interlinked channels
#if (UC3D)
  pwma->chgroup[1].ischset = channel_mask_high;
#else
  pwma->ischset1 = channel_mask_high;
8000243a:	f9 4b 00 40 	st.w	r12[64],r11
#endif
  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
8000243e:	78 78       	ld.w	r8,r12[0x1c]
80002440:	ed b8 00 03 	bld	r8,0x3
80002444:	cf d0       	breq	8000243e <pwma_config_and_enable+0x22>
      (period_cycles << AVR32_PWMA_CR_TOP_OFFSET) // Set the TOP and SPREAD values of the timebase counter
      | AVR32_PWMA_CR_TCLR_MASK                   // Clear the timebase counter
      | AVR32_PWMA_CR_EN_MASK;                    // Enable the PWMA

  pwma_set_channels_value(pwma, channel_mask, duty_cycles);
}
80002446:	5e fc       	retal	r12

80002448 <pwma_set_channels_value>:
  //# to allow multiple channels to be updated simultaneously with the same duty
  //# cycle
  //#

  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
80002448:	78 78       	ld.w	r8,r12[0x1c]
8000244a:	ed b8 00 03 	bld	r8,0x3
8000244e:	cf d0       	breq	80002448 <pwma_set_channels_value>

  //#
  //# First 32 channels
  //#
  // Set the common duty cycle value.
  pwma->isduty = duty_cycles;
80002450:	99 19       	st.w	r12[0x4],r9
  // Define the interlinked channels
#if (UC3D)
  pwma->chgroup[0].ischset = channel_mask_low;
#else
  pwma->ischset0 = channel_mask_low;
80002452:	99 ca       	st.w	r12[0x30],r10
#endif

  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
80002454:	78 78       	ld.w	r8,r12[0x1c]
80002456:	ed b8 00 03 	bld	r8,0x3
8000245a:	cf d0       	breq	80002454 <pwma_set_channels_value+0xc>

  //#
  //# Last 32 channels
  //#
  // Set the common duty cycle value.
  pwma->isduty = duty_cycles;
8000245c:	99 19       	st.w	r12[0x4],r9
  // Define the interlinked channels
#if (UC3D)
  pwma->chgroup[1].ischset = channel_mask_high;
#else
  pwma->ischset1 = channel_mask_high;
8000245e:	f9 4b 00 40 	st.w	r12[64],r11
#endif
  // Wait for the PWMA to be ready for writing.
  while (pwma->sr & AVR32_PWMA_SR_BUSY_MASK);
80002462:	78 78       	ld.w	r8,r12[0x1c]
80002464:	ed b8 00 03 	bld	r8,0x3
80002468:	cf d0       	breq	80002462 <pwma_set_channels_value+0x1a>
}
8000246a:	5e fc       	retal	r12

8000246c <scif_gc_setup>:
  return PASS;
}


long int scif_gc_setup(unsigned int gclk, scif_gcctrl_oscsel_t clk_src, unsigned int diven, unsigned int divfactor)
{
8000246c:	eb cd 40 c0 	pushm	r6-r7,lr
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
80002470:	fe 7e 18 00 	mov	lr,-59392
80002474:	f8 c8 ff e4 	sub	r8,r12,-28
80002478:	fc 08 03 2c 	ld.w	r12,lr[r8<<0x2]
{
  int restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
8000247c:	a1 99       	lsr	r9,0x1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000247e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
{
  int restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
80002482:	20 19       	sub	r9,1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
80002484:	58 0c       	cp.w	r12,0
80002486:	c1 21       	brne	800024aa <scif_gc_setup+0x3e>
    if(scif_stop_gclk(gclk) < 0)
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
80002488:	a1 7a       	lsl	r10,0x1
8000248a:	a9 6b       	lsl	r11,0x8
8000248c:	e2 1a 00 02 	andl	r10,0x2,COH
80002490:	e2 1b 0f 00 	andl	r11,0xf00,COH
80002494:	b1 69       	lsl	r9,0x10
80002496:	f5 eb 10 0b 	or	r11,r10,r11
8000249a:	e6 19 00 ff 	andh	r9,0xff,COH
8000249e:	f7 e9 10 09 	or	r9,r11,r9
800024a2:	fc 08 09 29 	st.w	lr[r8<<0x2],r9
  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= (AVR32_SCIF_GCCTRL_CEN_MASK);

  return PASS;
}
800024a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800024aa:	fc 08 03 2c 	ld.w	r12,lr[r8<<0x2]

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800024ae:	1c 96       	mov	r6,lr
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800024b0:	a1 cc       	cbr	r12,0x0
800024b2:	fc 08 09 2c 	st.w	lr[r8<<0x2],r12
800024b6:	30 0e       	mov	lr,0
800024b8:	c0 48       	rjmp	800024c0 <scif_gc_setup+0x54>

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
  {
    if(--timeout == 0)
800024ba:	e0 5e 86 a0 	cp.w	lr,100000
800024be:	c1 e0       	breq	800024fa <scif_gc_setup+0x8e>

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800024c0:	ec 08 03 2c 	ld.w	r12,r6[r8<<0x2]
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800024c4:	2f fe       	sub	lr,-1

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800024c6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800024ca:	fe 77 18 00 	mov	r7,-59392
800024ce:	cf 61       	brne	800024ba <scif_gc_setup+0x4e>
    if(scif_stop_gclk(gclk) < 0)
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800024d0:	a1 7a       	lsl	r10,0x1
800024d2:	a9 6b       	lsl	r11,0x8
800024d4:	e2 1a 00 02 	andl	r10,0x2,COH
800024d8:	e2 1b 0f 00 	andl	r11,0xf00,COH
800024dc:	b1 69       	lsl	r9,0x10
800024de:	16 4a       	or	r10,r11
800024e0:	e6 19 00 ff 	andh	r9,0xff,COH
800024e4:	f5 e9 10 09 	or	r9,r10,r9
800024e8:	ee 08 09 29 	st.w	r7[r8<<0x2],r9
                            |((diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((clk_src << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK);

  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= (AVR32_SCIF_GCCTRL_CEN_MASK);
800024ec:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
800024f0:	a1 a9       	sbr	r9,0x0
800024f2:	ee 08 09 29 	st.w	r7[r8<<0x2],r9
800024f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
  {
    if(--timeout == 0)
800024fa:	e3 cf c0 c0 	ldm	sp++,r6-r7,pc,r12=-1

800024fe <scif_gc_enable>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, do nothing.
  if(!(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK))
800024fe:	2e 4c       	sub	r12,-28
80002500:	fe 78 18 00 	mov	r8,-59392
80002504:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
80002508:	ed b9 00 00 	bld	r9,0x0
8000250c:	c0 60       	breq	80002518 <scif_gc_enable+0x1a>
    AVR32_SCIF.gcctrl[gclk] |= (AVR32_SCIF_GCCTRL_CEN_MASK);
8000250e:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
80002512:	a1 a9       	sbr	r9,0x0
80002514:	f0 0c 09 29 	st.w	r8[r12<<0x2],r9

  return PASS;
}
80002518:	5e fd       	retal	0

8000251a <scif_start_rc32k>:
/**
 ** 32kHz internal RCosc (RC32K) Functions
 **/
void scif_start_rc32k(void)
{
  AVR32_ENTER_CRITICAL_REGION( );
8000251a:	e1 b8 00 00 	mfsr	r8,0x0
8000251e:	d3 03       	ssrf	0x10
  // Unlock the write-protected RC32KCR register
  SCIF_UNLOCK(AVR32_SCIF_RC32KCR);
80002520:	fe 79 18 00 	mov	r9,-59392
80002524:	36 ca       	mov	r10,108
80002526:	ea 1a aa 00 	orh	r10,0xaa00
8000252a:	93 6a       	st.w	r9[0x18],r10
  AVR32_SCIF.rc32kcr = AVR32_SCIF_RC32KCR_EN_MASK;
8000252c:	30 1a       	mov	r10,1
8000252e:	f3 4a 00 6c 	st.w	r9[108],r10
  AVR32_LEAVE_CRITICAL_REGION( );
80002532:	ed b8 00 10 	bld	r8,0x10
80002536:	5e 0c       	reteq	r12
80002538:	d5 03       	csrf	0x10
8000253a:	5e fc       	retal	r12

8000253c <scif_start_rc120M>:
 ** 120MHz RCosc Functions
 **/

void scif_start_rc120M(void)
{
  AVR32_ENTER_CRITICAL_REGION( );
8000253c:	e1 b8 00 00 	mfsr	r8,0x0
80002540:	d3 03       	ssrf	0x10
  // Unlock the write-protected RC120MCR register
  SCIF_UNLOCK(AVR32_SCIF_RC120MCR);
80002542:	fe 79 18 00 	mov	r9,-59392
80002546:	35 8a       	mov	r10,88
80002548:	ea 1a aa 00 	orh	r10,0xaa00
8000254c:	93 6a       	st.w	r9[0x18],r10
  AVR32_SCIF.rc120mcr = AVR32_SCIF_RC120MCR_EN_MASK;
8000254e:	30 1a       	mov	r10,1
80002550:	f3 4a 00 58 	st.w	r9[88],r10
  AVR32_LEAVE_CRITICAL_REGION( );
80002554:	ed b8 00 10 	bld	r8,0x10
80002558:	5e 0c       	reteq	r12
8000255a:	d5 03       	csrf	0x10
8000255c:	5e fc       	retal	r12

8000255e <scif_dfll0_closedloop_start>:
  return PASS;
}


long int scif_dfll0_closedloop_start(const scif_dfll_closedloop_conf_t *pdfllconfig)
{
8000255e:	d4 01       	pushm	lr
80002560:	20 1d       	sub	sp,4
   || (pdfllconfig->coarsemaxstep >> AVR32_SCIF_DFLL0STEP_CSTEP_SIZE) )
    return -1;
#endif

  // Enable the DFLL0: DFLL0CONF.EN=1
  u_avr32_scif_dfll0conf.DFLL0CONF.en = ENABLE;
80002562:	30 18       	mov	r8,1
}


long int scif_dfll0_closedloop_start(const scif_dfll_closedloop_conf_t *pdfllconfig)
{
  u_avr32_scif_dfll0conf_t  u_avr32_scif_dfll0conf = {AVR32_SCIF.dfll0conf};
80002564:	fe 79 18 00 	mov	r9,-59392
80002568:	72 9e       	ld.w	lr,r9[0x24]
   || (pdfllconfig->coarsemaxstep >> AVR32_SCIF_DFLL0STEP_CSTEP_SIZE) )
    return -1;
#endif

  // Enable the DFLL0: DFLL0CONF.EN=1
  u_avr32_scif_dfll0conf.DFLL0CONF.en = ENABLE;
8000256a:	fd d8 d0 01 	bfins	lr,r8,0x0,0x1
  AVR32_ENTER_CRITICAL_REGION( );
8000256e:	e1 b8 00 00 	mfsr	r8,0x0
80002572:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
80002574:	32 4a       	mov	r10,36
80002576:	ea 1a aa 00 	orh	r10,0xaa00
8000257a:	93 6a       	st.w	r9[0x18],r10
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
8000257c:	93 9e       	st.w	r9[0x24],lr
  AVR32_LEAVE_CRITICAL_REGION( );
8000257e:	ed b8 00 10 	bld	r8,0x10
80002582:	c1 11       	brne	800025a4 <scif_dfll0_closedloop_start+0x46>
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
  {
    if(--timeout == 0)
80002584:	30 09       	mov	r9,0
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
80002586:	fe 7a 18 00 	mov	r10,-59392
8000258a:	74 58       	ld.w	r8,r10[0x14]
  // Enable the DFLL0: DFLL0CONF.EN=1
  u_avr32_scif_dfll0conf.DFLL0CONF.en = ENABLE;
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
  AVR32_LEAVE_CRITICAL_REGION( );
8000258c:	2f f9       	sub	r9,-1
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000258e:	e2 18 40 00 	andl	r8,0x4000,COH
80002592:	fe 7b 18 00 	mov	r11,-59392
80002596:	c0 91       	brne	800025a8 <scif_dfll0_closedloop_start+0x4a>
  {
    if(--timeout == 0)
80002598:	e0 59 86 a0 	cp.w	r9,100000
8000259c:	cf 71       	brne	8000258a <scif_dfll0_closedloop_start+0x2c>
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000259e:	3f fc       	mov	r12,-1
  // clock source with a highly accurate output clock.
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0LOCKF_MASK))
    return -1;

  return PASS;
}
800025a0:	2f fd       	sub	sp,-4
800025a2:	d8 02       	popm	pc
  // Enable the DFLL0: DFLL0CONF.EN=1
  u_avr32_scif_dfll0conf.DFLL0CONF.en = ENABLE;
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
  AVR32_LEAVE_CRITICAL_REGION( );
800025a4:	d5 03       	csrf	0x10
800025a6:	ce fb       	rjmp	80002584 <scif_dfll0_closedloop_start+0x26>
  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
    return -1;

  // Set the maxstep values
  tempo = ((pdfllconfig->coarsemaxstep << AVR32_SCIF_DFLL0STEP_CSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_CSTEP_MASK)
800025a8:	78 38       	ld.w	r8,r12[0xc]
800025aa:	f9 39 00 13 	ld.ub	r9,r12[19]
800025ae:	b1 68       	lsl	r8,0x10
800025b0:	e6 18 01 ff 	andh	r8,0x1ff,COH
800025b4:	12 48       	or	r8,r9
800025b6:	50 08       	stdsp	sp[0x0],r8
          | ((pdfllconfig->finemaxstep << AVR32_SCIF_DFLL0STEP_FSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_FSTEP_MASK);
  AVR32_ENTER_CRITICAL_REGION( );
800025b8:	e1 b8 00 00 	mfsr	r8,0x0
800025bc:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0STEP);
800025be:	32 c9       	mov	r9,44
800025c0:	ea 19 aa 00 	orh	r9,0xaa00
800025c4:	97 69       	st.w	r11[0x18],r9
  AVR32_SCIF.dfll0step = tempo;
800025c6:	40 09       	lddsp	r9,sp[0x0]
800025c8:	97 b9       	st.w	r11[0x2c],r9
  AVR32_LEAVE_CRITICAL_REGION( );
800025ca:	ed b8 00 10 	bld	r8,0x10
800025ce:	c0 f1       	brne	800025ec <scif_dfll0_closedloop_start+0x8e>
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
  {
    if(--timeout == 0)
800025d0:	30 09       	mov	r9,0
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800025d2:	fe 7a 18 00 	mov	r10,-59392
800025d6:	74 58       	ld.w	r8,r10[0x14]
  tempo = ((pdfllconfig->coarsemaxstep << AVR32_SCIF_DFLL0STEP_CSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_CSTEP_MASK)
          | ((pdfllconfig->finemaxstep << AVR32_SCIF_DFLL0STEP_FSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_FSTEP_MASK);
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0STEP);
  AVR32_SCIF.dfll0step = tempo;
  AVR32_LEAVE_CRITICAL_REGION( );
800025d8:	2f f9       	sub	r9,-1
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800025da:	e2 18 40 00 	andl	r8,0x4000,COH
800025de:	fe 7b 18 00 	mov	r11,-59392
800025e2:	c0 71       	brne	800025f0 <scif_dfll0_closedloop_start+0x92>
  {
    if(--timeout == 0)
800025e4:	e0 59 86 a0 	cp.w	r9,100000
800025e8:	cf 71       	brne	800025d6 <scif_dfll0_closedloop_start+0x78>
800025ea:	cd ab       	rjmp	8000259e <scif_dfll0_closedloop_start+0x40>
  tempo = ((pdfllconfig->coarsemaxstep << AVR32_SCIF_DFLL0STEP_CSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_CSTEP_MASK)
          | ((pdfllconfig->finemaxstep << AVR32_SCIF_DFLL0STEP_FSTEP_OFFSET)&AVR32_SCIF_DFLL0STEP_FSTEP_MASK);
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0STEP);
  AVR32_SCIF.dfll0step = tempo;
  AVR32_LEAVE_CRITICAL_REGION( );
800025ec:	d5 03       	csrf	0x10
800025ee:	cf 1b       	rjmp	800025d0 <scif_dfll0_closedloop_start+0x72>
  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
    return -1;

  // Set the fmul
  AVR32_ENTER_CRITICAL_REGION( );
800025f0:	e1 b8 00 00 	mfsr	r8,0x0
800025f4:	d3 03       	ssrf	0x10
#if AVR32_SCIF_H_VERSION < 110
  SCIF_UNLOCK(AVR32_SCIF_DFLL0FMUL);
800025f6:	32 89       	mov	r9,40
800025f8:	ea 19 aa 00 	orh	r9,0xaa00
800025fc:	97 69       	st.w	r11[0x18],r9
  AVR32_SCIF.dfll0fmul = (pdfllconfig->imul << AVR32_SCIF_DFLL0FMUL_FMUL_OFFSET)&AVR32_SCIF_DFLL0FMUL_FMUL_MASK;
800025fe:	78 29       	ld.w	r9,r12[0x8]
80002600:	97 a9       	st.w	r11[0x28],r9
#else
  SCIF_UNLOCK(AVR32_SCIF_DFLL0MUL);
  AVR32_SCIF.dfll0mul = ((pdfllconfig->fmul << AVR32_SCIF_DFLL0MUL_FMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_FMUL_MASK)
    | ((pdfllconfig->imul << AVR32_SCIF_DFLL0MUL_IMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_IMUL_MASK);
#endif
  AVR32_LEAVE_CRITICAL_REGION( );
80002602:	ed b8 00 10 	bld	r8,0x10
80002606:	c2 c1       	brne	8000265e <scif_dfll0_closedloop_start+0x100>
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
  {
    if(--timeout == 0)
80002608:	30 08       	mov	r8,0
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000260a:	fe 7b 18 00 	mov	r11,-59392
8000260e:	c0 48       	rjmp	80002616 <scif_dfll0_closedloop_start+0xb8>
  {
    if(--timeout == 0)
80002610:	e0 58 86 a0 	cp.w	r8,100000
80002614:	cc 50       	breq	8000259e <scif_dfll0_closedloop_start+0x40>
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
80002616:	76 59       	ld.w	r9,r11[0x14]
#else
  SCIF_UNLOCK(AVR32_SCIF_DFLL0MUL);
  AVR32_SCIF.dfll0mul = ((pdfllconfig->fmul << AVR32_SCIF_DFLL0MUL_FMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_FMUL_MASK)
    | ((pdfllconfig->imul << AVR32_SCIF_DFLL0MUL_IMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_IMUL_MASK);
#endif
  AVR32_LEAVE_CRITICAL_REGION( );
80002618:	2f f8       	sub	r8,-1
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000261a:	e2 19 40 00 	andl	r9,0x4000,COH
8000261e:	fe 7a 18 00 	mov	r10,-59392
80002622:	cf 70       	breq	80002610 <scif_dfll0_closedloop_start+0xb2>
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
    return -1;

  // Set the DFLL0 to operate in closed-loop mode: DFLL0CONF.MODE=1
  u_avr32_scif_dfll0conf.DFLL0CONF.mode = SCIF_DFLL0_MODE_CLOSEDLOOP;
  u_avr32_scif_dfll0conf.DFLL0CONF.coarse = pdfllconfig->coarse;
80002624:	78 08       	ld.w	r8,r12[0x0]
  // Wait for PCLKSR.DFLL0RDY is high
  if(scif_pclksr_statushigh_wait(AVR32_SCIF_PCLKSR_DFLL0RDY_MASK))
    return -1;

  // Set the DFLL0 to operate in closed-loop mode: DFLL0CONF.MODE=1
  u_avr32_scif_dfll0conf.DFLL0CONF.mode = SCIF_DFLL0_MODE_CLOSEDLOOP;
80002626:	30 19       	mov	r9,1
80002628:	fd d9 d0 21 	bfins	lr,r9,0x1,0x1
  u_avr32_scif_dfll0conf.DFLL0CONF.coarse = pdfllconfig->coarse;
8000262c:	fd d8 d3 08 	bfins	lr,r8,0x18,0x8
  AVR32_ENTER_CRITICAL_REGION( );
80002630:	e1 b8 00 00 	mfsr	r8,0x0
80002634:	d3 03       	ssrf	0x10
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
80002636:	32 49       	mov	r9,36
80002638:	ea 19 aa 00 	orh	r9,0xaa00
8000263c:	95 69       	st.w	r10[0x18],r9
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
8000263e:	95 9e       	st.w	r10[0x24],lr
  AVR32_LEAVE_CRITICAL_REGION( );
80002640:	e6 18 00 01 	andh	r8,0x1,COH
80002644:	c0 f0       	breq	80002662 <scif_dfll0_closedloop_start+0x104>
80002646:	30 08       	mov	r8,0
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
80002648:	fe 7a 18 00 	mov	r10,-59392
8000264c:	74 59       	ld.w	r9,r10[0x14]
8000264e:	ed b9 00 0e 	bld	r9,0xe
80002652:	c0 a0       	breq	80002666 <scif_dfll0_closedloop_start+0x108>
  u_avr32_scif_dfll0conf.DFLL0CONF.mode = SCIF_DFLL0_MODE_CLOSEDLOOP;
  u_avr32_scif_dfll0conf.DFLL0CONF.coarse = pdfllconfig->coarse;
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
  AVR32_LEAVE_CRITICAL_REGION( );
80002654:	2f f8       	sub	r8,-1
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
  {
    if(--timeout == 0)
80002656:	e0 58 86 a0 	cp.w	r8,100000
8000265a:	cf 91       	brne	8000264c <scif_dfll0_closedloop_start+0xee>
8000265c:	ca 1b       	rjmp	8000259e <scif_dfll0_closedloop_start+0x40>
#else
  SCIF_UNLOCK(AVR32_SCIF_DFLL0MUL);
  AVR32_SCIF.dfll0mul = ((pdfllconfig->fmul << AVR32_SCIF_DFLL0MUL_FMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_FMUL_MASK)
    | ((pdfllconfig->imul << AVR32_SCIF_DFLL0MUL_IMUL_OFFSET)&AVR32_SCIF_DFLL0MUL_IMUL_MASK);
#endif
  AVR32_LEAVE_CRITICAL_REGION( );
8000265e:	d5 03       	csrf	0x10
80002660:	cd 4b       	rjmp	80002608 <scif_dfll0_closedloop_start+0xaa>
  u_avr32_scif_dfll0conf.DFLL0CONF.mode = SCIF_DFLL0_MODE_CLOSEDLOOP;
  u_avr32_scif_dfll0conf.DFLL0CONF.coarse = pdfllconfig->coarse;
  AVR32_ENTER_CRITICAL_REGION( );
  SCIF_UNLOCK(AVR32_SCIF_DFLL0CONF);
  AVR32_SCIF.dfll0conf = u_avr32_scif_dfll0conf.dfll0conf;
  AVR32_LEAVE_CRITICAL_REGION( );
80002662:	d5 03       	csrf	0x10
80002664:	cf 2b       	rjmp	80002648 <scif_dfll0_closedloop_start+0xea>
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
80002666:	30 08       	mov	r8,0
80002668:	fe 7a 18 00 	mov	r10,-59392
8000266c:	74 59       	ld.w	r9,r10[0x14]
8000266e:	ed b9 00 09 	bld	r9,0x9
80002672:	c0 60       	breq	8000267e <scif_dfll0_closedloop_start+0x120>
80002674:	2f f8       	sub	r8,-1
  {
    if(--timeout == 0)
80002676:	e0 58 86 a0 	cp.w	r8,100000
8000267a:	cf 91       	brne	8000266c <scif_dfll0_closedloop_start+0x10e>
8000267c:	c9 1b       	rjmp	8000259e <scif_dfll0_closedloop_start+0x40>
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
8000267e:	30 0c       	mov	r12,0
80002680:	c9 0b       	rjmp	800025a0 <scif_dfll0_closedloop_start+0x42>
80002682:	d7 03       	nop

80002684 <scif_dfll0_closedloop_configure_and_start>:


long int scif_dfll0_closedloop_configure_and_start( const scif_gclk_opt_t *gc_dfllif_ref_opt,
                                                    unsigned long long target_freq_hz,
                                                    bool enable_ssg)
{
80002684:	d4 31       	pushm	r0-r7,lr
80002686:	20 8d       	sub	sp,32
80002688:	16 97       	mov	r7,r11
8000268a:	14 96       	mov	r6,r10
  int gc_source_clock_freq_hz;

  // This function only supports the following source clocks for the CLK_DFLLIF_REF generic clock:
  // SCIF_GCCTRL_SLOWCLOCK (aka RCSYS), SCIF_GCCTRL_OSC32K, SCIF_GCCTRL_RC32K,
  // SCIF_GCCTRL_OSC0, SCIF_GCCTRL_RC120M, SCIF_GCCTRL_CLK1K.
  if(SCIF_GCCTRL_SLOWCLOCK == gc_dfllif_ref_opt->clock_source)
8000268c:	78 0b       	ld.w	r11,r12[0x0]
8000268e:	58 0b       	cp.w	r11,0
80002690:	c7 00       	breq	80002770 <scif_dfll0_closedloop_configure_and_start+0xec>
    gc_source_clock_freq_hz = SCIF_SLOWCLOCK_FREQ_HZ;
  else if((SCIF_GCCTRL_OSC32K == gc_dfllif_ref_opt->clock_source) || (SCIF_GCCTRL_RC32K == gc_dfllif_ref_opt->clock_source))
80002692:	58 9b       	cp.w	r11,9
80002694:	5f 09       	sreq	r9
80002696:	58 1b       	cp.w	r11,1
80002698:	5f 08       	sreq	r8
8000269a:	f3 e8 10 08 	or	r8,r9,r8
8000269e:	c6 c1       	brne	80002776 <scif_dfll0_closedloop_configure_and_start+0xf2>
    gc_source_clock_freq_hz = SCIF_RC32K_FREQ_HZ;
  else if(SCIF_GCCTRL_OSC0 == gc_dfllif_ref_opt->clock_source)
800026a0:	58 3b       	cp.w	r11,3
800026a2:	c6 d0       	breq	8000277c <scif_dfll0_closedloop_configure_and_start+0xf8>
    gc_source_clock_freq_hz = gc_dfllif_ref_opt->extosc_f;
  else if(SCIF_GCCTRL_RC120M == gc_dfllif_ref_opt->clock_source)
800026a4:	58 4b       	cp.w	r11,4
800026a6:	c0 60       	breq	800026b2 <scif_dfll0_closedloop_configure_and_start+0x2e>
    gc_source_clock_freq_hz = SCIF_RC120M_FREQ_HZ;
  else if(SCIF_GCCTRL_CLK1K == gc_dfllif_ref_opt->clock_source)
800026a8:	58 bb       	cp.w	r11,11
800026aa:	c6 00       	breq	8000276a <scif_dfll0_closedloop_configure_and_start+0xe6>
  DfllConfig.coarsemaxstep = 0x0000004;

  // Dithering disabled.

  // Configure and start the DFLL0 in closed loop mode.
  if(scif_dfll0_closedloop_start(&DfllConfig))
800026ac:	3f fc       	mov	r12,-1
  if(true == enable_ssg)
  {
  ;
  }
  return PASS;
}
800026ae:	2f 8d       	sub	sp,-32
800026b0:	d8 32       	popm	r0-r7,pc
    gc_source_clock_freq_hz = SCIF_SLOWCLOCK_FREQ_HZ;
  else if((SCIF_GCCTRL_OSC32K == gc_dfllif_ref_opt->clock_source) || (SCIF_GCCTRL_RC32K == gc_dfllif_ref_opt->clock_source))
    gc_source_clock_freq_hz = SCIF_RC32K_FREQ_HZ;
  else if(SCIF_GCCTRL_OSC0 == gc_dfllif_ref_opt->clock_source)
    gc_source_clock_freq_hz = gc_dfllif_ref_opt->extosc_f;
  else if(SCIF_GCCTRL_RC120M == gc_dfllif_ref_opt->clock_source)
800026b2:	e0 65 0e 00 	mov	r5,3584
800026b6:	ea 15 07 27 	orh	r5,0x727
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, return an error.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800026ba:	fe 7a 18 00 	mov	r10,-59392
800026be:	75 c4       	ld.w	r4,r10[0x70]
800026c0:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800026c4:	cf 41       	brne	800026ac <scif_dfll0_closedloop_configure_and_start+0x28>
    return -1;

  // Configure & start the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((opt->divider << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
                            |((opt->diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
800026c6:	78 22       	ld.w	r2,r12[0x8]
  // If the generic clock is already enabled, return an error.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
    return -1;

  // Configure & start the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((opt->divider << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800026c8:	a9 6b       	lsl	r11,0x8
800026ca:	78 1c       	ld.w	r12,r12[0x4]
800026cc:	e2 1b 0f 00 	andl	r11,0xf00,COH
800026d0:	50 0c       	stdsp	sp[0x0],r12
800026d2:	18 93       	mov	r3,r12
800026d4:	e4 0c 15 01 	lsl	r12,r2,0x1
800026d8:	b1 63       	lsl	r3,0x10
800026da:	e2 1c 00 02 	andl	r12,0x2,COH
800026de:	e6 13 00 ff 	andh	r3,0xff,COH
800026e2:	e7 ec 10 0c 	or	r12,r3,r12
800026e6:	a1 ac       	sbr	r12,0x0
800026e8:	16 4c       	or	r12,r11
  if(scif_dfll0_closedloop_mainref_gc_enable(gc_dfllif_ref_opt))
    return(-1);

  // Configure the DFLL.
  // The coarse value (= (dfll_f - SCIF_DFLL_MINFREQ_KHZ)*255/(SCIF_DFLL_MAXFREQ_KHZ - SCIF_DFLL_MINFREQ_KHZ))
  DfllConfig.coarse = ((unsigned long long)(target_freq_hz - SCIF_DFLL_MINFREQ_HZ)*255)/(SCIF_DFLL_MAXFREQ_HZ - SCIF_DFLL_MINFREQ_HZ);
800026ea:	0e 9b       	mov	r11,r7
  // If the generic clock is already enabled, return an error.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
    return -1;

  // Configure & start the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((opt->divider << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800026ec:	f5 4c 00 70 	st.w	r10[112],r12
  if(scif_dfll0_closedloop_mainref_gc_enable(gc_dfllif_ref_opt))
    return(-1);

  // Configure the DFLL.
  // The coarse value (= (dfll_f - SCIF_DFLL_MINFREQ_KHZ)*255/(SCIF_DFLL_MAXFREQ_KHZ - SCIF_DFLL_MINFREQ_KHZ))
  DfllConfig.coarse = ((unsigned long long)(target_freq_hz - SCIF_DFLL_MINFREQ_HZ)*255)/(SCIF_DFLL_MAXFREQ_HZ - SCIF_DFLL_MINFREQ_HZ);
800026f0:	a9 6b       	lsl	r11,0x8
800026f2:	ec 0a 15 08 	lsl	r10,r6,0x8
800026f6:	f7 e6 13 8b 	or	r11,r11,r6>>0x18
800026fa:	e0 68 77 80 	mov	r8,30592
800026fe:	ea 18 06 8e 	orh	r8,0x68e
80002702:	f4 06 01 00 	sub	r0,r10,r6
80002706:	f6 07 01 41 	sbc	r1,r11,r7
8000270a:	30 09       	mov	r9,0
8000270c:	e0 6a 5a 00 	mov	r10,23040
80002710:	ea 1a a0 08 	orh	r10,0xa008
80002714:	3f db       	mov	r11,-3
80002716:	e0 0a 00 0a 	add	r10,r0,r10
8000271a:	e2 0b 00 4b 	adc	r11,r1,r11
8000271e:	e0 a0 07 29 	rcall	80003570 <__avr32_udiv64>

  // imul = (fDFLL)/fref,
  // fmul = (fDFLL*2^16)/fref - imul*2^16,
  // with fref being the frequency of the DFLL main reference generic clock
  // and fDFLL being the target frequency of the DFLL
  DfllConfig.imul = ((unsigned long long)target_freq_hz)/gc_source_clock_freq_hz;
80002722:	ea 01 14 1f 	asr	r1,r5,0x1f
  if(scif_dfll0_closedloop_mainref_gc_enable(gc_dfllif_ref_opt))
    return(-1);

  // Configure the DFLL.
  // The coarse value (= (dfll_f - SCIF_DFLL_MINFREQ_KHZ)*255/(SCIF_DFLL_MAXFREQ_KHZ - SCIF_DFLL_MINFREQ_KHZ))
  DfllConfig.coarse = ((unsigned long long)(target_freq_hz - SCIF_DFLL_MINFREQ_HZ)*255)/(SCIF_DFLL_MAXFREQ_HZ - SCIF_DFLL_MINFREQ_HZ);
80002726:	50 3a       	stdsp	sp[0xc],r10

  // imul = (fDFLL)/fref,
  // fmul = (fDFLL*2^16)/fref - imul*2^16,
  // with fref being the frequency of the DFLL main reference generic clock
  // and fDFLL being the target frequency of the DFLL
  DfllConfig.imul = ((unsigned long long)target_freq_hz)/gc_source_clock_freq_hz;
80002728:	0a 98       	mov	r8,r5
8000272a:	02 99       	mov	r9,r1
8000272c:	0c 9a       	mov	r10,r6
8000272e:	0e 9b       	mov	r11,r7
80002730:	e0 a0 07 20 	rcall	80003570 <__avr32_udiv64>
80002734:	50 5a       	stdsp	sp[0x14],r10
80002736:	14 93       	mov	r3,r10
  if(0 == gc_dfllif_ref_opt->diven)
80002738:	58 02       	cp.w	r2,0
8000273a:	c2 31       	brne	80002780 <scif_dfll0_closedloop_configure_and_start+0xfc>
  {
    DfllConfig.fmul = ((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16);
8000273c:	02 99       	mov	r9,r1
8000273e:	0a 98       	mov	r8,r5
80002740:	0c 9a       	mov	r10,r6
80002742:	0e 9b       	mov	r11,r7
80002744:	b1 6a       	lsl	r10,0x10
80002746:	b1 6b       	lsl	r11,0x10
80002748:	b1 63       	lsl	r3,0x10
8000274a:	f7 e6 13 0b 	or	r11,r11,r6>>0x10
8000274e:	0c 90       	mov	r0,r6
80002750:	e0 a0 07 10 	rcall	80003570 <__avr32_udiv64>
80002754:	f4 03 01 03 	sub	r3,r10,r3
80002758:	50 43       	stdsp	sp[0x10],r3
  }
  else
    DfllConfig.fmul = ((((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16))<<1)*(1+gc_dfllif_ref_opt->divider);

  // The fine and coarse maxstep values
  DfllConfig.finemaxstep = 0x0000004;
8000275a:	30 48       	mov	r8,4
  DfllConfig.coarsemaxstep = 0x0000004;

  // Dithering disabled.

  // Configure and start the DFLL0 in closed loop mode.
  if(scif_dfll0_closedloop_start(&DfllConfig))
8000275c:	fa cc ff f4 	sub	r12,sp,-12
  else
    DfllConfig.fmul = ((((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16))<<1)*(1+gc_dfllif_ref_opt->divider);

  // The fine and coarse maxstep values
  DfllConfig.finemaxstep = 0x0000004;
  DfllConfig.coarsemaxstep = 0x0000004;
80002760:	50 78       	stdsp	sp[0x1c],r8
  }
  else
    DfllConfig.fmul = ((((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16))<<1)*(1+gc_dfllif_ref_opt->divider);

  // The fine and coarse maxstep values
  DfllConfig.finemaxstep = 0x0000004;
80002762:	50 68       	stdsp	sp[0x18],r8
  DfllConfig.coarsemaxstep = 0x0000004;

  // Dithering disabled.

  // Configure and start the DFLL0 in closed loop mode.
  if(scif_dfll0_closedloop_start(&DfllConfig))
80002764:	cf de       	rcall	8000255e <scif_dfll0_closedloop_start>
80002766:	ca 40       	breq	800026ae <scif_dfll0_closedloop_configure_and_start+0x2a>
80002768:	ca 2b       	rjmp	800026ac <scif_dfll0_closedloop_configure_and_start+0x28>
8000276a:	e0 65 03 e8 	mov	r5,1000
    gc_source_clock_freq_hz = SCIF_RC32K_FREQ_HZ;
  else if(SCIF_GCCTRL_OSC0 == gc_dfllif_ref_opt->clock_source)
    gc_source_clock_freq_hz = gc_dfllif_ref_opt->extosc_f;
  else if(SCIF_GCCTRL_RC120M == gc_dfllif_ref_opt->clock_source)
    gc_source_clock_freq_hz = SCIF_RC120M_FREQ_HZ;
  else if(SCIF_GCCTRL_CLK1K == gc_dfllif_ref_opt->clock_source)
8000276e:	ca 6b       	rjmp	800026ba <scif_dfll0_closedloop_configure_and_start+0x36>
80002770:	e0 75 c2 00 	mov	r5,115200
  int gc_source_clock_freq_hz;

  // This function only supports the following source clocks for the CLK_DFLLIF_REF generic clock:
  // SCIF_GCCTRL_SLOWCLOCK (aka RCSYS), SCIF_GCCTRL_OSC32K, SCIF_GCCTRL_RC32K,
  // SCIF_GCCTRL_OSC0, SCIF_GCCTRL_RC120M, SCIF_GCCTRL_CLK1K.
  if(SCIF_GCCTRL_SLOWCLOCK == gc_dfllif_ref_opt->clock_source)
80002774:	ca 3b       	rjmp	800026ba <scif_dfll0_closedloop_configure_and_start+0x36>
80002776:	e0 65 80 00 	mov	r5,32768
    gc_source_clock_freq_hz = SCIF_SLOWCLOCK_FREQ_HZ;
  else if((SCIF_GCCTRL_OSC32K == gc_dfllif_ref_opt->clock_source) || (SCIF_GCCTRL_RC32K == gc_dfllif_ref_opt->clock_source))
8000277a:	ca 0b       	rjmp	800026ba <scif_dfll0_closedloop_configure_and_start+0x36>
8000277c:	78 35       	ld.w	r5,r12[0xc]
    gc_source_clock_freq_hz = SCIF_RC32K_FREQ_HZ;
  else if(SCIF_GCCTRL_OSC0 == gc_dfllif_ref_opt->clock_source)
    gc_source_clock_freq_hz = gc_dfllif_ref_opt->extosc_f;
8000277e:	c9 eb       	rjmp	800026ba <scif_dfll0_closedloop_configure_and_start+0x36>
80002780:	02 99       	mov	r9,r1
  if(0 == gc_dfllif_ref_opt->diven)
  {
    DfllConfig.fmul = ((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16);
  }
  else
    DfllConfig.fmul = ((((unsigned long long)target_freq_hz<<16)/gc_source_clock_freq_hz - ((unsigned long long)(DfllConfig.imul)<<16))<<1)*(1+gc_dfllif_ref_opt->divider);
80002782:	0a 98       	mov	r8,r5
80002784:	0c 9a       	mov	r10,r6
80002786:	0e 9b       	mov	r11,r7
80002788:	b1 6a       	lsl	r10,0x10
8000278a:	b1 6b       	lsl	r11,0x10
8000278c:	f7 e6 13 0b 	or	r11,r11,r6>>0x10
80002790:	e0 a0 06 f0 	rcall	80003570 <__avr32_udiv64>
80002794:	e6 09 16 10 	lsr	r9,r3,0x10
80002798:	40 00       	lddsp	r0,sp[0x0]
8000279a:	e6 08 15 10 	lsl	r8,r3,0x10
8000279e:	2f f0       	sub	r0,-1
800027a0:	f4 08 01 08 	sub	r8,r10,r8
800027a4:	f6 09 01 49 	sbc	r9,r11,r9
800027a8:	10 08       	add	r8,r8
800027aa:	f2 09 00 49 	adc	r9,r9,r9
800027ae:	b1 30       	mul	r0,r8
800027b0:	50 40       	stdsp	sp[0x10],r0
800027b2:	cd 4b       	rjmp	8000275a <scif_dfll0_closedloop_configure_and_start+0xd6>

800027b4 <scif_enable_osc>:
800027b4:	fe 78 18 00 	mov	r8,-59392
800027b8:	70 79       	ld.w	r9,r8[0x1c]
800027ba:	f3 db d1 03 	bfins	r9,r11,0x8,0x3
800027be:	30 1b       	mov	r11,1
  u_avr32_scif_oscctrl0_t   u_avr32_scif_oscctrl0 = {AVR32_SCIF.oscctrl0};


  // Configure the oscillator startup and enable the osc.
  u_avr32_scif_oscctrl0.OSCCTRL0.startup = startup;
  u_avr32_scif_oscctrl0.OSCCTRL0.oscen = ENABLE;
800027c0:	f3 db d2 01 	bfins	r9,r11,0x10,0x1
  AVR32_ENTER_CRITICAL_REGION( );
800027c4:	e1 bb 00 00 	mfsr	r11,0x0
800027c8:	d3 03       	ssrf	0x10
  // Unlock the write-protected OSCCTRL0 register
  SCIF_UNLOCK(AVR32_SCIF_OSCCTRL0);
800027ca:	31 cc       	mov	r12,28
800027cc:	ea 1c aa 00 	orh	r12,0xaa00
800027d0:	91 6c       	st.w	r8[0x18],r12
  // Write
  AVR32_SCIF.oscctrl0 = u_avr32_scif_oscctrl0.oscctrl0;
800027d2:	91 79       	st.w	r8[0x1c],r9
  AVR32_LEAVE_CRITICAL_REGION( );
800027d4:	ed bb 00 10 	bld	r11,0x10
800027d8:	c0 41       	brne	800027e0 <scif_enable_osc+0x2c>

  if(true == wait_for_ready)
800027da:	58 0a       	cp.w	r10,0
800027dc:	c0 41       	brne	800027e4 <scif_enable_osc+0x30>
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800027de:	5e fd       	retal	0
  AVR32_ENTER_CRITICAL_REGION( );
  // Unlock the write-protected OSCCTRL0 register
  SCIF_UNLOCK(AVR32_SCIF_OSCCTRL0);
  // Write
  AVR32_SCIF.oscctrl0 = u_avr32_scif_oscctrl0.oscctrl0;
  AVR32_LEAVE_CRITICAL_REGION( );
800027e0:	d5 03       	csrf	0x10
800027e2:	cf cb       	rjmp	800027da <scif_enable_osc+0x26>

  if(true == wait_for_ready)
800027e4:	30 09       	mov	r9,0
 */
long int scif_pclksr_statushigh_wait(unsigned long statusMask)
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
800027e6:	fe 7a 18 00 	mov	r10,-59392
800027ea:	74 58       	ld.w	r8,r10[0x14]
800027ec:	ed b8 00 01 	bld	r8,0x1
800027f0:	cf 70       	breq	800027de <scif_enable_osc+0x2a>
  SCIF_UNLOCK(AVR32_SCIF_OSCCTRL0);
  // Write
  AVR32_SCIF.oscctrl0 = u_avr32_scif_oscctrl0.oscctrl0;
  AVR32_LEAVE_CRITICAL_REGION( );

  if(true == wait_for_ready)
800027f2:	2f f9       	sub	r9,-1
{
  unsigned int  timeout = SCIF_POLL_TIMEOUT;

  while(!(AVR32_SCIF.pclksr & statusMask))
  {
    if(--timeout == 0)
800027f4:	e0 59 86 a0 	cp.w	r9,100000
800027f8:	cf 91       	brne	800027ea <scif_enable_osc+0x36>
800027fa:	5e fe       	retal	-1

800027fc <scif_configure_osc_crystalmode>:

long int scif_configure_osc_crystalmode(scif_osc_t osc, unsigned int fcrystal)
{
//# Implementation note: this code doesn't consider the osc input parameter
//# because UC3L devices only implement OSC0.
  u_avr32_scif_oscctrl0_t   u_avr32_scif_oscctrl0 = {AVR32_SCIF.oscctrl0};
800027fc:	fe 78 18 00 	mov	r8,-59392
80002800:	70 78       	ld.w	r8,r8[0x1c]

  // Configure the oscillator mode to crystal and set the gain according to the
  // cyrstal frequency.
  u_avr32_scif_oscctrl0.OSCCTRL0.mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
  u_avr32_scif_oscctrl0.OSCCTRL0.gain = (fcrystal <  900000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
80002802:	ec 5b bb 9f 	cp.w	r11,899999
80002806:	e0 8b 00 17 	brhi	80002834 <scif_configure_osc_crystalmode+0x38>
8000280a:	30 0b       	mov	r11,0
//# because UC3L devices only implement OSC0.
  u_avr32_scif_oscctrl0_t   u_avr32_scif_oscctrl0 = {AVR32_SCIF.oscctrl0};

  // Configure the oscillator mode to crystal and set the gain according to the
  // cyrstal frequency.
  u_avr32_scif_oscctrl0.OSCCTRL0.mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
8000280c:	30 19       	mov	r9,1
8000280e:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_scif_oscctrl0.OSCCTRL0.gain = (fcrystal <  900000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
80002812:	f1 db d0 22 	bfins	r8,r11,0x1,0x2
                                        (fcrystal < 3000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G1 :
                                        (fcrystal < 8000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G2 :
                                                               AVR32_SCIF_OSCCTRL0_GAIN_G3;
  AVR32_ENTER_CRITICAL_REGION( );
80002816:	e1 b9 00 00 	mfsr	r9,0x0
8000281a:	d3 03       	ssrf	0x10
  // Unlock the write-protected OSCCTRL0 register
  SCIF_UNLOCK(AVR32_SCIF_OSCCTRL0);
8000281c:	fe 7a 18 00 	mov	r10,-59392
80002820:	31 cb       	mov	r11,28
80002822:	ea 1b aa 00 	orh	r11,0xaa00
80002826:	95 6b       	st.w	r10[0x18],r11
  // Write
  AVR32_SCIF.oscctrl0 = u_avr32_scif_oscctrl0.oscctrl0;
80002828:	95 78       	st.w	r10[0x1c],r8
  AVR32_LEAVE_CRITICAL_REGION( );
8000282a:	ed b9 00 10 	bld	r9,0x10
8000282e:	c0 20       	breq	80002832 <scif_configure_osc_crystalmode+0x36>
80002830:	d5 03       	csrf	0x10
  // Add here after support for OSC1 for devices that implement OSC1.

  return PASS;
}
80002832:	5e fd       	retal	0
  u_avr32_scif_oscctrl0_t   u_avr32_scif_oscctrl0 = {AVR32_SCIF.oscctrl0};

  // Configure the oscillator mode to crystal and set the gain according to the
  // cyrstal frequency.
  u_avr32_scif_oscctrl0.OSCCTRL0.mode = SCIF_OSC_MODE_2PIN_CRYSTAL;
  u_avr32_scif_oscctrl0.OSCCTRL0.gain = (fcrystal <  900000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
80002834:	e0 69 c6 bf 	mov	r9,50879
80002838:	ea 19 00 2d 	orh	r9,0x2d
8000283c:	12 3b       	cp.w	r11,r9
8000283e:	e0 88 00 0c 	brls	80002856 <scif_configure_osc_crystalmode+0x5a>
80002842:	e0 69 12 00 	mov	r9,4608
80002846:	ea 19 00 7a 	orh	r9,0x7a
8000284a:	12 3b       	cp.w	r11,r9
8000284c:	f9 bb 03 02 	movlo	r11,2
80002850:	f9 bb 02 03 	movhs	r11,3
80002854:	cd cb       	rjmp	8000280c <scif_configure_osc_crystalmode+0x10>
80002856:	30 1b       	mov	r11,1
80002858:	cd ab       	rjmp	8000280c <scif_configure_osc_crystalmode+0x10>
8000285a:	d7 03       	nop

8000285c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000285c:	e0 6d 40 00 	mov	sp,16384

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80002860:	fe c0 ee 60 	sub	r0,pc,-4512

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80002864:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80002868:	d5 53       	csrf	0x15
  cp      r0, r1
8000286a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
8000286c:	34 81       	mov	r1,72
  lda.w   r2, _data_lma
8000286e:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
80002870:	c0 72       	brcc	8000287e <idata_load_loop_end>
  st.d    r0++, r4
80002872:	fe c2 eb 5a 	sub	r2,pc,-5286

80002876 <idata_load_loop>:
  cp      r0, r1
  brlo    idata_load_loop
80002876:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80002878:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000287a:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000287c:	cf d3       	brcs	80002876 <idata_load_loop>

8000287e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000287e:	34 80       	mov	r0,72
  mov     r2, 0
80002880:	e0 61 01 40 	mov	r1,320
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80002884:	02 30       	cp.w	r0,r1
  cp      r0, r1
80002886:	c0 62       	brcc	80002892 <udata_clear_loop_end>
  brlo    udata_clear_loop
80002888:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000288a:	30 03       	mov	r3,0

8000288c <udata_clear_loop>:
8000288c:	a1 22       	st.d	r0++,r2
8000288e:	02 30       	cp.w	r0,r1
80002890:	cf e3       	brcs	8000288c <udata_clear_loop>

80002892 <udata_clear_loop_end>:
80002892:	fe cf f5 8e 	sub	pc,pc,-2674
80002896:	d7 03       	nop

80002898 <turn_right>:
}



void turn_right(void)
{
80002898:	eb cd 40 80 	pushm	r7,lr
	// Lift Legs
	servos[1][1] += 10;
8000289c:	30 c7       	mov	r7,12
8000289e:	0f c8       	ld.ub	r8,r7[0x4]
800028a0:	2f 68       	sub	r8,-10
800028a2:	5c 58       	castu.b	r8
800028a4:	10 99       	mov	r9,r8
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
800028a6:	ae c8       	st.b	r7[0x4],r8


void turn_right(void)
{
	// Lift Legs
	servos[1][1] += 10;
800028a8:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] += 10;
800028aa:	2f 68       	sub	r8,-10
800028ac:	ae d8       	st.b	r7[0x5],r8
800028ae:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] += 10;
800028b2:	2f 68       	sub	r8,-10
800028b4:	ef 68 00 0a 	st.b	r7[10],r8
800028b8:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] += 10;
800028bc:	2f 68       	sub	r8,-10
800028be:	ef 68 00 0b 	st.b	r7[11],r8
800028c2:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] += 10;
800028c6:	2f 68       	sub	r8,-10
800028c8:	ef 68 00 10 	st.b	r7[16],r8
800028cc:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] += 10;
800028d0:	2f 68       	sub	r8,-10
800028d2:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
800028d6:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] += 10;
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
800028da:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
800028dc:	fe 7c 54 00 	mov	r12,-44032
800028e0:	fe b0 fd b4 	rcall	80002448 <pwma_set_channels_value>
800028e4:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
800028e6:	30 1a       	mov	r10,1
800028e8:	30 1b       	mov	r11,1
800028ea:	fe 7c 54 00 	mov	r12,-44032
800028ee:	fe b0 fd ad 	rcall	80002448 <pwma_set_channels_value>
800028f2:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
800028f6:	e0 6a 02 01 	mov	r10,513
800028fa:	30 0b       	mov	r11,0
800028fc:	fe 7c 54 00 	mov	r12,-44032
80002900:	fe b0 fd a4 	rcall	80002448 <pwma_set_channels_value>
80002904:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
80002908:	e0 6a 10 01 	mov	r10,4097
8000290c:	30 0b       	mov	r11,0
8000290e:	fe 7c 54 00 	mov	r12,-44032
80002912:	fe b0 fd 9b 	rcall	80002448 <pwma_set_channels_value>
80002916:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
8000291a:	e0 7a 00 01 	mov	r10,65537
8000291e:	30 0b       	mov	r11,0
80002920:	fe 7c 54 00 	mov	r12,-44032
80002924:	fe b0 fd 92 	rcall	80002448 <pwma_set_channels_value>
80002928:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
8000292c:	e0 6a 80 01 	mov	r10,32769
80002930:	30 0b       	mov	r11,0
80002932:	fe 7c 54 00 	mov	r12,-44032
80002936:	fe b0 fd 89 	rcall	80002448 <pwma_set_channels_value>
8000293a:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Body Forward
	servos[0][0] -= 4;
8000293c:	20 48       	sub	r8,4
8000293e:	5c 58       	castu.b	r8
80002940:	10 99       	mov	r9,r8
	servos[2][0] -= 4;
	servos[4][0] -= 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002942:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Move Body Forward
	servos[0][0] -= 4;
80002944:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] -= 4;
80002946:	20 48       	sub	r8,4
80002948:	ae e8       	st.b	r7[0x6],r8
8000294a:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] -= 4;
8000294e:	20 48       	sub	r8,4
80002950:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002952:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Body Forward
	servos[0][0] -= 4;
	servos[2][0] -= 4;
	servos[4][0] -= 4;
80002956:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002958:	fe 7c 54 00 	mov	r12,-44032
8000295c:	fe b0 fd 76 	rcall	80002448 <pwma_set_channels_value>
80002960:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80002962:	30 1a       	mov	r10,1
80002964:	ea 1a 20 00 	orh	r10,0x2000
80002968:	30 0b       	mov	r11,0
8000296a:	fe 7c 54 00 	mov	r12,-44032
8000296e:	fe b0 fd 6d 	rcall	80002448 <pwma_set_channels_value>
80002972:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
80002976:	30 1a       	mov	r10,1
80002978:	30 4b       	mov	r11,4
8000297a:	fe 7c 54 00 	mov	r12,-44032
8000297e:	fe b0 fd 65 	rcall	80002448 <pwma_set_channels_value>
80002982:	0f c8       	ld.ub	r8,r7[0x4]
	
	
	
	// Drop Legs
	servos[1][1] -= 10;
80002984:	20 a8       	sub	r8,10
80002986:	5c 58       	castu.b	r8
80002988:	10 99       	mov	r9,r8
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
8000298a:	ae c8       	st.b	r7[0x4],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	
	// Drop Legs
	servos[1][1] -= 10;
8000298c:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] -= 10;
8000298e:	20 a8       	sub	r8,10
80002990:	ae d8       	st.b	r7[0x5],r8
80002992:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] -= 10;
80002996:	20 a8       	sub	r8,10
80002998:	ef 68 00 0a 	st.b	r7[10],r8
8000299c:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] -= 10;
800029a0:	20 a8       	sub	r8,10
800029a2:	ef 68 00 0b 	st.b	r7[11],r8
800029a6:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] -= 10;
800029aa:	20 a8       	sub	r8,10
800029ac:	ef 68 00 10 	st.b	r7[16],r8
800029b0:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] -= 10;
800029b4:	20 a8       	sub	r8,10
800029b6:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
800029ba:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] -= 10;
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
800029be:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
800029c0:	fe 7c 54 00 	mov	r12,-44032
800029c4:	fe b0 fd 42 	rcall	80002448 <pwma_set_channels_value>
800029c8:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
800029ca:	30 1a       	mov	r10,1
800029cc:	30 1b       	mov	r11,1
800029ce:	fe 7c 54 00 	mov	r12,-44032
800029d2:	fe b0 fd 3b 	rcall	80002448 <pwma_set_channels_value>
800029d6:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
800029da:	e0 6a 02 01 	mov	r10,513
800029de:	30 0b       	mov	r11,0
800029e0:	fe 7c 54 00 	mov	r12,-44032
800029e4:	fe b0 fd 32 	rcall	80002448 <pwma_set_channels_value>
800029e8:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
800029ec:	e0 6a 10 01 	mov	r10,4097
800029f0:	30 0b       	mov	r11,0
800029f2:	fe 7c 54 00 	mov	r12,-44032
800029f6:	fe b0 fd 29 	rcall	80002448 <pwma_set_channels_value>
800029fa:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
800029fe:	e0 7a 00 01 	mov	r10,65537
80002a02:	30 0b       	mov	r11,0
80002a04:	fe 7c 54 00 	mov	r12,-44032
80002a08:	fe b0 fd 20 	rcall	80002448 <pwma_set_channels_value>
80002a0c:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
80002a10:	e0 6a 80 01 	mov	r10,32769
80002a14:	30 0b       	mov	r11,0
80002a16:	fe 7c 54 00 	mov	r12,-44032
80002a1a:	fe b0 fd 17 	rcall	80002448 <pwma_set_channels_value>
80002a1e:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	// Lift Legs
	servos[0][1] += 6;
80002a20:	2f a8       	sub	r8,-6
80002a22:	5c 58       	castu.b	r8
80002a24:	10 99       	mov	r9,r8
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002a26:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Lift Legs
	servos[0][1] += 6;
80002a28:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] += 6;
80002a2a:	2f a8       	sub	r8,-6
80002a2c:	ae a8       	st.b	r7[0x2],r8
80002a2e:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] += 6;
80002a30:	2f a8       	sub	r8,-6
80002a32:	ae f8       	st.b	r7[0x7],r8
80002a34:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] += 6;
80002a38:	2f a8       	sub	r8,-6
80002a3a:	ef 68 00 08 	st.b	r7[8],r8
80002a3e:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] += 6;
80002a42:	2f a8       	sub	r8,-6
80002a44:	ef 68 00 0d 	st.b	r7[13],r8
80002a48:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] += 6;
80002a4c:	2f a8       	sub	r8,-6
80002a4e:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002a50:	ea 1a 00 20 	orh	r10,0x20
80002a54:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] += 6;
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
80002a58:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002a5a:	fe 7c 54 00 	mov	r12,-44032
80002a5e:	fe b0 fc f5 	rcall	80002448 <pwma_set_channels_value>
80002a62:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80002a64:	30 1a       	mov	r10,1
80002a66:	ea 1a 00 10 	orh	r10,0x10
80002a6a:	30 0b       	mov	r11,0
80002a6c:	fe 7c 54 00 	mov	r12,-44032
80002a70:	fe b0 fc ec 	rcall	80002448 <pwma_set_channels_value>
80002a74:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
80002a76:	30 1a       	mov	r10,1
80002a78:	ea 1a 40 00 	orh	r10,0x4000
80002a7c:	30 0b       	mov	r11,0
80002a7e:	fe 7c 54 00 	mov	r12,-44032
80002a82:	fe b0 fc e3 	rcall	80002448 <pwma_set_channels_value>
80002a86:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80002a8a:	30 1a       	mov	r10,1
80002a8c:	ea 1a 80 00 	orh	r10,0x8000
80002a90:	30 0b       	mov	r11,0
80002a92:	fe 7c 54 00 	mov	r12,-44032
80002a96:	fe b0 fc d9 	rcall	80002448 <pwma_set_channels_value>
80002a9a:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
80002a9e:	e4 6a 00 01 	mov	r10,262145
80002aa2:	30 0b       	mov	r11,0
80002aa4:	fe 7c 54 00 	mov	r12,-44032
80002aa8:	fe b0 fc d0 	rcall	80002448 <pwma_set_channels_value>
80002aac:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
80002ab0:	e8 6a 00 01 	mov	r10,524289
80002ab4:	30 0b       	mov	r11,0
80002ab6:	fe 7c 54 00 	mov	r12,-44032
80002aba:	fe b0 fc c7 	rcall	80002448 <pwma_set_channels_value>
80002abe:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002ac0:	2f c8       	sub	r8,-4
80002ac2:	5c 58       	castu.b	r8
80002ac4:	10 99       	mov	r9,r8
	servos[2][0] += 4;
	servos[4][0] += 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002ac6:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002ac8:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] += 4;
80002aca:	2f c8       	sub	r8,-4
80002acc:	ae e8       	st.b	r7[0x6],r8
80002ace:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] += 4;
80002ad2:	2f c8       	sub	r8,-4
80002ad4:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002ad6:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Body Forward
	servos[0][0] += 4;
	servos[2][0] += 4;
	servos[4][0] += 4;
80002ada:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002adc:	fe 7c 54 00 	mov	r12,-44032
80002ae0:	fe b0 fc b4 	rcall	80002448 <pwma_set_channels_value>
80002ae4:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80002ae6:	30 1a       	mov	r10,1
80002ae8:	ea 1a 20 00 	orh	r10,0x2000
80002aec:	30 0b       	mov	r11,0
80002aee:	fe 7c 54 00 	mov	r12,-44032
80002af2:	fe b0 fc ab 	rcall	80002448 <pwma_set_channels_value>
80002af6:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
80002afa:	30 1a       	mov	r10,1
80002afc:	30 4b       	mov	r11,4
80002afe:	fe 7c 54 00 	mov	r12,-44032
80002b02:	fe b0 fc a3 	rcall	80002448 <pwma_set_channels_value>
80002b06:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	
	// Drop Legs
	servos[0][1] -= 6;
80002b08:	20 68       	sub	r8,6
80002b0a:	5c 58       	castu.b	r8
80002b0c:	10 99       	mov	r9,r8
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002b0e:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	
	// Drop Legs
	servos[0][1] -= 6;
80002b10:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] -= 6;
80002b12:	20 68       	sub	r8,6
80002b14:	ae a8       	st.b	r7[0x2],r8
80002b16:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] -= 6;
80002b18:	20 68       	sub	r8,6
80002b1a:	ae f8       	st.b	r7[0x7],r8
80002b1c:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] -= 6;
80002b20:	20 68       	sub	r8,6
80002b22:	ef 68 00 08 	st.b	r7[8],r8
80002b26:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] -= 6;
80002b2a:	20 68       	sub	r8,6
80002b2c:	ef 68 00 0d 	st.b	r7[13],r8
80002b30:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] -= 6;
80002b34:	20 68       	sub	r8,6
80002b36:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002b38:	ea 1a 00 20 	orh	r10,0x20
80002b3c:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] -= 6;
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
80002b40:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002b42:	fe 7c 54 00 	mov	r12,-44032
80002b46:	fe b0 fc 81 	rcall	80002448 <pwma_set_channels_value>
80002b4a:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80002b4c:	30 1a       	mov	r10,1
80002b4e:	ea 1a 00 10 	orh	r10,0x10
80002b52:	30 0b       	mov	r11,0
80002b54:	fe 7c 54 00 	mov	r12,-44032
80002b58:	fe b0 fc 78 	rcall	80002448 <pwma_set_channels_value>
80002b5c:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
80002b5e:	30 1a       	mov	r10,1
80002b60:	ea 1a 40 00 	orh	r10,0x4000
80002b64:	30 0b       	mov	r11,0
80002b66:	fe 7c 54 00 	mov	r12,-44032
80002b6a:	fe b0 fc 6f 	rcall	80002448 <pwma_set_channels_value>
80002b6e:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80002b72:	30 1a       	mov	r10,1
80002b74:	ea 1a 80 00 	orh	r10,0x8000
80002b78:	30 0b       	mov	r11,0
80002b7a:	fe 7c 54 00 	mov	r12,-44032
80002b7e:	fe b0 fc 65 	rcall	80002448 <pwma_set_channels_value>
80002b82:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
80002b86:	e4 6a 00 01 	mov	r10,262145
80002b8a:	30 0b       	mov	r11,0
80002b8c:	fe 7c 54 00 	mov	r12,-44032
80002b90:	fe b0 fc 5c 	rcall	80002448 <pwma_set_channels_value>
80002b94:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
80002b98:	e8 6a 00 01 	mov	r10,524289
80002b9c:	30 0b       	mov	r11,0
80002b9e:	fe 7c 54 00 	mov	r12,-44032
80002ba2:	fe b0 fc 53 	rcall	80002448 <pwma_set_channels_value>
80002ba6:	e3 cd 80 80 	ldm	sp++,r7,pc
}
80002baa:	d7 03       	nop

80002bac <turn_left>:
80002bac:	eb cd 40 80 	pushm	r7,lr
80002bb0:	30 c7       	mov	r7,12
80002bb2:	0f c8       	ld.ub	r8,r7[0x4]


void turn_left(void)
{
	// Lift Legs
	servos[1][1] += 10;
80002bb4:	2f 68       	sub	r8,-10
80002bb6:	5c 58       	castu.b	r8
80002bb8:	10 99       	mov	r9,r8
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002bba:	ae c8       	st.b	r7[0x4],r8


void turn_left(void)
{
	// Lift Legs
	servos[1][1] += 10;
80002bbc:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] += 10;
80002bbe:	2f 68       	sub	r8,-10
80002bc0:	ae d8       	st.b	r7[0x5],r8
80002bc2:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] += 10;
80002bc6:	2f 68       	sub	r8,-10
80002bc8:	ef 68 00 0a 	st.b	r7[10],r8
80002bcc:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] += 10;
80002bd0:	2f 68       	sub	r8,-10
80002bd2:	ef 68 00 0b 	st.b	r7[11],r8
80002bd6:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] += 10;
80002bda:	2f 68       	sub	r8,-10
80002bdc:	ef 68 00 10 	st.b	r7[16],r8
80002be0:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] += 10;
80002be4:	2f 68       	sub	r8,-10
80002be6:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002bea:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] += 10;
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
80002bee:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002bf0:	fe 7c 54 00 	mov	r12,-44032
80002bf4:	fe b0 fc 2a 	rcall	80002448 <pwma_set_channels_value>
80002bf8:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
80002bfa:	30 1a       	mov	r10,1
80002bfc:	30 1b       	mov	r11,1
80002bfe:	fe 7c 54 00 	mov	r12,-44032
80002c02:	fe b0 fc 23 	rcall	80002448 <pwma_set_channels_value>
80002c06:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
80002c0a:	e0 6a 02 01 	mov	r10,513
80002c0e:	30 0b       	mov	r11,0
80002c10:	fe 7c 54 00 	mov	r12,-44032
80002c14:	fe b0 fc 1a 	rcall	80002448 <pwma_set_channels_value>
80002c18:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
80002c1c:	e0 6a 10 01 	mov	r10,4097
80002c20:	30 0b       	mov	r11,0
80002c22:	fe 7c 54 00 	mov	r12,-44032
80002c26:	fe b0 fc 11 	rcall	80002448 <pwma_set_channels_value>
80002c2a:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
80002c2e:	e0 7a 00 01 	mov	r10,65537
80002c32:	30 0b       	mov	r11,0
80002c34:	fe 7c 54 00 	mov	r12,-44032
80002c38:	fe b0 fc 08 	rcall	80002448 <pwma_set_channels_value>
80002c3c:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
80002c40:	e0 6a 80 01 	mov	r10,32769
80002c44:	30 0b       	mov	r11,0
80002c46:	fe 7c 54 00 	mov	r12,-44032
80002c4a:	fe b0 fb ff 	rcall	80002448 <pwma_set_channels_value>
80002c4e:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002c50:	2f c8       	sub	r8,-4
80002c52:	5c 58       	castu.b	r8
80002c54:	10 99       	mov	r9,r8
	servos[2][0] += 4;
	servos[4][0] += 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002c56:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002c58:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] += 4;
80002c5a:	2f c8       	sub	r8,-4
80002c5c:	ae e8       	st.b	r7[0x6],r8
80002c5e:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] += 4;
80002c62:	2f c8       	sub	r8,-4
80002c64:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002c66:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Body Forward
	servos[0][0] += 4;
	servos[2][0] += 4;
	servos[4][0] += 4;
80002c6a:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002c6c:	fe 7c 54 00 	mov	r12,-44032
80002c70:	fe b0 fb ec 	rcall	80002448 <pwma_set_channels_value>
80002c74:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80002c76:	30 1a       	mov	r10,1
80002c78:	ea 1a 20 00 	orh	r10,0x2000
80002c7c:	30 0b       	mov	r11,0
80002c7e:	fe 7c 54 00 	mov	r12,-44032
80002c82:	fe b0 fb e3 	rcall	80002448 <pwma_set_channels_value>
80002c86:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
80002c8a:	30 1a       	mov	r10,1
80002c8c:	30 4b       	mov	r11,4
80002c8e:	fe 7c 54 00 	mov	r12,-44032
80002c92:	fe b0 fb db 	rcall	80002448 <pwma_set_channels_value>
80002c96:	0f c8       	ld.ub	r8,r7[0x4]
	
	
	
	// Drop Legs
	servos[1][1] -= 10;
80002c98:	20 a8       	sub	r8,10
80002c9a:	5c 58       	castu.b	r8
80002c9c:	10 99       	mov	r9,r8
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002c9e:	ae c8       	st.b	r7[0x4],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	
	// Drop Legs
	servos[1][1] -= 10;
80002ca0:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] -= 10;
80002ca2:	20 a8       	sub	r8,10
80002ca4:	ae d8       	st.b	r7[0x5],r8
80002ca6:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] -= 10;
80002caa:	20 a8       	sub	r8,10
80002cac:	ef 68 00 0a 	st.b	r7[10],r8
80002cb0:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] -= 10;
80002cb4:	20 a8       	sub	r8,10
80002cb6:	ef 68 00 0b 	st.b	r7[11],r8
80002cba:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] -= 10;
80002cbe:	20 a8       	sub	r8,10
80002cc0:	ef 68 00 10 	st.b	r7[16],r8
80002cc4:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] -= 10;
80002cc8:	20 a8       	sub	r8,10
80002cca:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002cce:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] -= 10;
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
80002cd2:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002cd4:	fe 7c 54 00 	mov	r12,-44032
80002cd8:	fe b0 fb b8 	rcall	80002448 <pwma_set_channels_value>
80002cdc:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
80002cde:	30 1a       	mov	r10,1
80002ce0:	30 1b       	mov	r11,1
80002ce2:	fe 7c 54 00 	mov	r12,-44032
80002ce6:	fe b0 fb b1 	rcall	80002448 <pwma_set_channels_value>
80002cea:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
80002cee:	e0 6a 02 01 	mov	r10,513
80002cf2:	30 0b       	mov	r11,0
80002cf4:	fe 7c 54 00 	mov	r12,-44032
80002cf8:	fe b0 fb a8 	rcall	80002448 <pwma_set_channels_value>
80002cfc:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
80002d00:	e0 6a 10 01 	mov	r10,4097
80002d04:	30 0b       	mov	r11,0
80002d06:	fe 7c 54 00 	mov	r12,-44032
80002d0a:	fe b0 fb 9f 	rcall	80002448 <pwma_set_channels_value>
80002d0e:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
80002d12:	e0 7a 00 01 	mov	r10,65537
80002d16:	30 0b       	mov	r11,0
80002d18:	fe 7c 54 00 	mov	r12,-44032
80002d1c:	fe b0 fb 96 	rcall	80002448 <pwma_set_channels_value>
80002d20:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
80002d24:	e0 6a 80 01 	mov	r10,32769
80002d28:	30 0b       	mov	r11,0
80002d2a:	fe 7c 54 00 	mov	r12,-44032
80002d2e:	fe b0 fb 8d 	rcall	80002448 <pwma_set_channels_value>
80002d32:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	// Lift Legs
	servos[0][1] += 6;
80002d34:	2f a8       	sub	r8,-6
80002d36:	5c 58       	castu.b	r8
80002d38:	10 99       	mov	r9,r8
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002d3a:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Lift Legs
	servos[0][1] += 6;
80002d3c:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] += 6;
80002d3e:	2f a8       	sub	r8,-6
80002d40:	ae a8       	st.b	r7[0x2],r8
80002d42:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] += 6;
80002d44:	2f a8       	sub	r8,-6
80002d46:	ae f8       	st.b	r7[0x7],r8
80002d48:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] += 6;
80002d4c:	2f a8       	sub	r8,-6
80002d4e:	ef 68 00 08 	st.b	r7[8],r8
80002d52:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] += 6;
80002d56:	2f a8       	sub	r8,-6
80002d58:	ef 68 00 0d 	st.b	r7[13],r8
80002d5c:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] += 6;
80002d60:	2f a8       	sub	r8,-6
80002d62:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002d64:	ea 1a 00 20 	orh	r10,0x20
80002d68:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] += 6;
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
80002d6c:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002d6e:	fe 7c 54 00 	mov	r12,-44032
80002d72:	fe b0 fb 6b 	rcall	80002448 <pwma_set_channels_value>
80002d76:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80002d78:	30 1a       	mov	r10,1
80002d7a:	ea 1a 00 10 	orh	r10,0x10
80002d7e:	30 0b       	mov	r11,0
80002d80:	fe 7c 54 00 	mov	r12,-44032
80002d84:	fe b0 fb 62 	rcall	80002448 <pwma_set_channels_value>
80002d88:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
80002d8a:	30 1a       	mov	r10,1
80002d8c:	ea 1a 40 00 	orh	r10,0x4000
80002d90:	30 0b       	mov	r11,0
80002d92:	fe 7c 54 00 	mov	r12,-44032
80002d96:	fe b0 fb 59 	rcall	80002448 <pwma_set_channels_value>
80002d9a:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80002d9e:	30 1a       	mov	r10,1
80002da0:	ea 1a 80 00 	orh	r10,0x8000
80002da4:	30 0b       	mov	r11,0
80002da6:	fe 7c 54 00 	mov	r12,-44032
80002daa:	fe b0 fb 4f 	rcall	80002448 <pwma_set_channels_value>
80002dae:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
80002db2:	e4 6a 00 01 	mov	r10,262145
80002db6:	30 0b       	mov	r11,0
80002db8:	fe 7c 54 00 	mov	r12,-44032
80002dbc:	fe b0 fb 46 	rcall	80002448 <pwma_set_channels_value>
80002dc0:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
80002dc4:	e8 6a 00 01 	mov	r10,524289
80002dc8:	30 0b       	mov	r11,0
80002dca:	fe 7c 54 00 	mov	r12,-44032
80002dce:	fe b0 fb 3d 	rcall	80002448 <pwma_set_channels_value>
80002dd2:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Legs Forward
	servos[0][0] -= 4;
80002dd4:	20 48       	sub	r8,4
80002dd6:	5c 58       	castu.b	r8
80002dd8:	10 99       	mov	r9,r8
	servos[2][0] -= 4;
	servos[4][0] -= 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002dda:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
	
	
	// Move Legs Forward
	servos[0][0] -= 4;
80002ddc:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] -= 4;
80002dde:	20 48       	sub	r8,4
80002de0:	ae e8       	st.b	r7[0x6],r8
80002de2:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] -= 4;
80002de6:	20 48       	sub	r8,4
80002de8:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002dea:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Legs Forward
	servos[0][0] -= 4;
	servos[2][0] -= 4;
	servos[4][0] -= 4;
80002dee:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002df0:	fe 7c 54 00 	mov	r12,-44032
80002df4:	fe b0 fb 2a 	rcall	80002448 <pwma_set_channels_value>
80002df8:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80002dfa:	30 1a       	mov	r10,1
80002dfc:	ea 1a 20 00 	orh	r10,0x2000
80002e00:	30 0b       	mov	r11,0
80002e02:	fe 7c 54 00 	mov	r12,-44032
80002e06:	fe b0 fb 21 	rcall	80002448 <pwma_set_channels_value>
80002e0a:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
80002e0e:	30 1a       	mov	r10,1
80002e10:	30 4b       	mov	r11,4
80002e12:	fe 7c 54 00 	mov	r12,-44032
80002e16:	fe b0 fb 19 	rcall	80002448 <pwma_set_channels_value>
80002e1a:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	// Drop Legs
	servos[0][1] -= 6;
80002e1c:	20 68       	sub	r8,6
80002e1e:	5c 58       	castu.b	r8
80002e20:	10 99       	mov	r9,r8
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002e22:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	// Drop Legs
	servos[0][1] -= 6;
80002e24:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] -= 6;
80002e26:	20 68       	sub	r8,6
80002e28:	ae a8       	st.b	r7[0x2],r8
80002e2a:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] -= 6;
80002e2c:	20 68       	sub	r8,6
80002e2e:	ae f8       	st.b	r7[0x7],r8
80002e30:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] -= 6;
80002e34:	20 68       	sub	r8,6
80002e36:	ef 68 00 08 	st.b	r7[8],r8
80002e3a:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] -= 6;
80002e3e:	20 68       	sub	r8,6
80002e40:	ef 68 00 0d 	st.b	r7[13],r8
80002e44:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] -= 6;
80002e48:	20 68       	sub	r8,6
80002e4a:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002e4c:	ea 1a 00 20 	orh	r10,0x20
80002e50:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] -= 6;
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
80002e54:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80002e56:	fe 7c 54 00 	mov	r12,-44032
80002e5a:	fe b0 fa f7 	rcall	80002448 <pwma_set_channels_value>
80002e5e:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80002e60:	30 1a       	mov	r10,1
80002e62:	ea 1a 00 10 	orh	r10,0x10
80002e66:	30 0b       	mov	r11,0
80002e68:	fe 7c 54 00 	mov	r12,-44032
80002e6c:	fe b0 fa ee 	rcall	80002448 <pwma_set_channels_value>
80002e70:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
80002e72:	30 1a       	mov	r10,1
80002e74:	ea 1a 40 00 	orh	r10,0x4000
80002e78:	30 0b       	mov	r11,0
80002e7a:	fe 7c 54 00 	mov	r12,-44032
80002e7e:	fe b0 fa e5 	rcall	80002448 <pwma_set_channels_value>
80002e82:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80002e86:	30 1a       	mov	r10,1
80002e88:	ea 1a 80 00 	orh	r10,0x8000
80002e8c:	30 0b       	mov	r11,0
80002e8e:	fe 7c 54 00 	mov	r12,-44032
80002e92:	fe b0 fa db 	rcall	80002448 <pwma_set_channels_value>
80002e96:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
80002e9a:	e4 6a 00 01 	mov	r10,262145
80002e9e:	30 0b       	mov	r11,0
80002ea0:	fe 7c 54 00 	mov	r12,-44032
80002ea4:	fe b0 fa d2 	rcall	80002448 <pwma_set_channels_value>
80002ea8:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
80002eac:	e8 6a 00 01 	mov	r10,524289
80002eb0:	30 0b       	mov	r11,0
80002eb2:	fe 7c 54 00 	mov	r12,-44032
80002eb6:	fe b0 fa c9 	rcall	80002448 <pwma_set_channels_value>
80002eba:	e3 cd 80 80 	ldm	sp++,r7,pc
}
80002ebe:	d7 03       	nop

80002ec0 <walk_forward>:
80002ec0:	eb cd 40 80 	pushm	r7,lr
80002ec4:	30 c7       	mov	r7,12
80002ec6:	0f c8       	ld.ub	r8,r7[0x4]


void walk_forward(void)
{
	// Lift Legs
	servos[1][1] += 10;
80002ec8:	2f 68       	sub	r8,-10
80002eca:	5c 58       	castu.b	r8
80002ecc:	10 99       	mov	r9,r8
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002ece:	ae c8       	st.b	r7[0x4],r8


void walk_forward(void)
{
	// Lift Legs
	servos[1][1] += 10;
80002ed0:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] += 10;
80002ed2:	2f 68       	sub	r8,-10
80002ed4:	ae d8       	st.b	r7[0x5],r8
80002ed6:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] += 10;
80002eda:	2f 68       	sub	r8,-10
80002edc:	ef 68 00 0a 	st.b	r7[10],r8
80002ee0:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] += 10;
80002ee4:	2f 68       	sub	r8,-10
80002ee6:	ef 68 00 0b 	st.b	r7[11],r8
80002eea:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] += 10;
80002eee:	2f 68       	sub	r8,-10
80002ef0:	ef 68 00 10 	st.b	r7[16],r8
80002ef4:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] += 10;
80002ef8:	2f 68       	sub	r8,-10
80002efa:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002efe:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] += 10;
	servos[1][2] += 10;
	servos[3][1] += 10;
	servos[3][2] += 10;
	servos[5][1] += 10;
	servos[5][2] += 10;
80002f02:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80002f04:	fe 7c 54 00 	mov	r12,-44032
80002f08:	fe b0 fa a0 	rcall	80002448 <pwma_set_channels_value>
80002f0c:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
80002f0e:	30 1a       	mov	r10,1
80002f10:	30 1b       	mov	r11,1
80002f12:	fe 7c 54 00 	mov	r12,-44032
80002f16:	fe b0 fa 99 	rcall	80002448 <pwma_set_channels_value>
80002f1a:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
80002f1e:	e0 6a 02 01 	mov	r10,513
80002f22:	30 0b       	mov	r11,0
80002f24:	fe 7c 54 00 	mov	r12,-44032
80002f28:	fe b0 fa 90 	rcall	80002448 <pwma_set_channels_value>
80002f2c:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
80002f30:	e0 6a 10 01 	mov	r10,4097
80002f34:	30 0b       	mov	r11,0
80002f36:	fe 7c 54 00 	mov	r12,-44032
80002f3a:	fe b0 fa 87 	rcall	80002448 <pwma_set_channels_value>
80002f3e:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
80002f42:	e0 7a 00 01 	mov	r10,65537
80002f46:	30 0b       	mov	r11,0
80002f48:	fe 7c 54 00 	mov	r12,-44032
80002f4c:	fe b0 fa 7e 	rcall	80002448 <pwma_set_channels_value>
80002f50:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
80002f54:	e0 6a 80 01 	mov	r10,32769
80002f58:	30 0b       	mov	r11,0
80002f5a:	fe 7c 54 00 	mov	r12,-44032
80002f5e:	fe b0 fa 75 	rcall	80002448 <pwma_set_channels_value>
80002f62:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002f64:	2f c8       	sub	r8,-4
80002f66:	5c 58       	castu.b	r8
80002f68:	10 99       	mov	r9,r8
	servos[2][0] += 4;
	servos[4][0] -= 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002f6a:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Move Body Forward
	servos[0][0] += 4;
80002f6c:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] += 4;
80002f6e:	2f c8       	sub	r8,-4
80002f70:	ae e8       	st.b	r7[0x6],r8
80002f72:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] -= 4;
80002f76:	20 48       	sub	r8,4
80002f78:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002f7a:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Body Forward
	servos[0][0] += 4;
	servos[2][0] += 4;
	servos[4][0] -= 4;
80002f7e:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80002f80:	fe 7c 54 00 	mov	r12,-44032
80002f84:	fe b0 fa 62 	rcall	80002448 <pwma_set_channels_value>
80002f88:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80002f8a:	30 1a       	mov	r10,1
80002f8c:	ea 1a 20 00 	orh	r10,0x2000
80002f90:	30 0b       	mov	r11,0
80002f92:	fe 7c 54 00 	mov	r12,-44032
80002f96:	fe b0 fa 59 	rcall	80002448 <pwma_set_channels_value>
80002f9a:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
80002f9e:	30 1a       	mov	r10,1
80002fa0:	30 4b       	mov	r11,4
80002fa2:	fe 7c 54 00 	mov	r12,-44032
80002fa6:	fe b0 fa 51 	rcall	80002448 <pwma_set_channels_value>
80002faa:	0f b8       	ld.ub	r8,r7[0x3]
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
80002fac:	20 48       	sub	r8,4
80002fae:	5c 58       	castu.b	r8
80002fb0:	10 99       	mov	r9,r8
	servos[3][0] += 4;
	servos[5][0] += 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
80002fb2:	ae b8       	st.b	r7[0x3],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
80002fb4:	ef 38 00 09 	ld.ub	r8,r7[9]
	servos[3][0] += 4;
80002fb8:	2f c8       	sub	r8,-4
80002fba:	ef 68 00 09 	st.b	r7[9],r8
80002fbe:	ef 38 00 0f 	ld.ub	r8,r7[15]
	servos[5][0] += 4;
80002fc2:	2f c8       	sub	r8,-4
80002fc4:	e0 6a 20 01 	mov	r10,8193
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
80002fc8:	ef 68 00 0f 	st.b	r7[15],r8
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
	servos[3][0] += 4;
	servos[5][0] += 4;
80002fcc:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
80002fce:	fe 7c 54 00 	mov	r12,-44032
80002fd2:	fe b0 fa 3b 	rcall	80002448 <pwma_set_channels_value>
80002fd6:	ef 39 00 09 	ld.ub	r9,r7[9]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
80002fda:	30 1a       	mov	r10,1
80002fdc:	30 8b       	mov	r11,8
80002fde:	fe 7c 54 00 	mov	r12,-44032
80002fe2:	fe b0 fa 33 	rcall	80002448 <pwma_set_channels_value>
80002fe6:	ef 39 00 0f 	ld.ub	r9,r7[15]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
80002fea:	e2 6a 00 01 	mov	r10,131073
80002fee:	30 0b       	mov	r11,0
80002ff0:	fe 7c 54 00 	mov	r12,-44032
80002ff4:	fe b0 fa 2a 	rcall	80002448 <pwma_set_channels_value>
80002ff8:	0f c8       	ld.ub	r8,r7[0x4]
	
	
	// Drop Legs
	servos[1][1] -= 10;
80002ffa:	20 a8       	sub	r8,10
80002ffc:	5c 58       	castu.b	r8
80002ffe:	10 99       	mov	r9,r8
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80003000:	ae c8       	st.b	r7[0x4],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
	
	
	// Drop Legs
	servos[1][1] -= 10;
80003002:	0f d8       	ld.ub	r8,r7[0x5]
	servos[1][2] -= 10;
80003004:	20 a8       	sub	r8,10
80003006:	ae d8       	st.b	r7[0x5],r8
80003008:	ef 38 00 0a 	ld.ub	r8,r7[10]
	servos[3][1] -= 10;
8000300c:	20 a8       	sub	r8,10
8000300e:	ef 68 00 0a 	st.b	r7[10],r8
80003012:	ef 38 00 0b 	ld.ub	r8,r7[11]
	servos[3][2] -= 10;
80003016:	20 a8       	sub	r8,10
80003018:	ef 68 00 0b 	st.b	r7[11],r8
8000301c:	ef 38 00 10 	ld.ub	r8,r7[16]
	servos[5][1] -= 10;
80003020:	20 a8       	sub	r8,10
80003022:	ef 68 00 10 	st.b	r7[16],r8
80003026:	ef 38 00 11 	ld.ub	r8,r7[17]
	servos[5][2] -= 10;
8000302a:	20 a8       	sub	r8,10
8000302c:	e0 6a 08 01 	mov	r10,2049
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80003030:	ef 68 00 11 	st.b	r7[17],r8
	servos[1][1] -= 10;
	servos[1][2] -= 10;
	servos[3][1] -= 10;
	servos[3][2] -= 10;
	servos[5][1] -= 10;
	servos[5][2] -= 10;
80003034:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
80003036:	fe 7c 54 00 	mov	r12,-44032
8000303a:	fe b0 fa 07 	rcall	80002448 <pwma_set_channels_value>
8000303e:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
80003040:	30 1a       	mov	r10,1
80003042:	30 1b       	mov	r11,1
80003044:	fe 7c 54 00 	mov	r12,-44032
80003048:	fe b0 fa 00 	rcall	80002448 <pwma_set_channels_value>
8000304c:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
80003050:	e0 6a 02 01 	mov	r10,513
80003054:	30 0b       	mov	r11,0
80003056:	fe 7c 54 00 	mov	r12,-44032
8000305a:	fe b0 f9 f7 	rcall	80002448 <pwma_set_channels_value>
8000305e:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
80003062:	e0 6a 10 01 	mov	r10,4097
80003066:	30 0b       	mov	r11,0
80003068:	fe 7c 54 00 	mov	r12,-44032
8000306c:	fe b0 f9 ee 	rcall	80002448 <pwma_set_channels_value>
80003070:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
80003074:	e0 7a 00 01 	mov	r10,65537
80003078:	30 0b       	mov	r11,0
8000307a:	fe 7c 54 00 	mov	r12,-44032
8000307e:	fe b0 f9 e5 	rcall	80002448 <pwma_set_channels_value>
80003082:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
80003086:	e0 6a 80 01 	mov	r10,32769
8000308a:	30 0b       	mov	r11,0
8000308c:	fe 7c 54 00 	mov	r12,-44032
80003090:	fe b0 f9 dc 	rcall	80002448 <pwma_set_channels_value>
80003094:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	// Lift Legs
	servos[0][1] += 6;
80003096:	2f a8       	sub	r8,-6
80003098:	5c 58       	castu.b	r8
8000309a:	10 99       	mov	r9,r8
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
8000309c:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
	
	
	// Lift Legs
	servos[0][1] += 6;
8000309e:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] += 6;
800030a0:	2f a8       	sub	r8,-6
800030a2:	ae a8       	st.b	r7[0x2],r8
800030a4:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] += 6;
800030a6:	2f a8       	sub	r8,-6
800030a8:	ae f8       	st.b	r7[0x7],r8
800030aa:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] += 6;
800030ae:	2f a8       	sub	r8,-6
800030b0:	ef 68 00 08 	st.b	r7[8],r8
800030b4:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] += 6;
800030b8:	2f a8       	sub	r8,-6
800030ba:	ef 68 00 0d 	st.b	r7[13],r8
800030be:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] += 6;
800030c2:	2f a8       	sub	r8,-6
800030c4:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
800030c6:	ea 1a 00 20 	orh	r10,0x20
800030ca:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] += 6;
	servos[0][2] += 6;
	servos[2][1] += 6;
	servos[2][2] += 6;
	servos[4][1] += 6;
	servos[4][2] += 6;
800030ce:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
800030d0:	fe 7c 54 00 	mov	r12,-44032
800030d4:	fe b0 f9 ba 	rcall	80002448 <pwma_set_channels_value>
800030d8:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
800030da:	30 1a       	mov	r10,1
800030dc:	ea 1a 00 10 	orh	r10,0x10
800030e0:	30 0b       	mov	r11,0
800030e2:	fe 7c 54 00 	mov	r12,-44032
800030e6:	fe b0 f9 b1 	rcall	80002448 <pwma_set_channels_value>
800030ea:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
800030ec:	30 1a       	mov	r10,1
800030ee:	ea 1a 40 00 	orh	r10,0x4000
800030f2:	30 0b       	mov	r11,0
800030f4:	fe 7c 54 00 	mov	r12,-44032
800030f8:	fe b0 f9 a8 	rcall	80002448 <pwma_set_channels_value>
800030fc:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80003100:	30 1a       	mov	r10,1
80003102:	ea 1a 80 00 	orh	r10,0x8000
80003106:	30 0b       	mov	r11,0
80003108:	fe 7c 54 00 	mov	r12,-44032
8000310c:	fe b0 f9 9e 	rcall	80002448 <pwma_set_channels_value>
80003110:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
80003114:	e4 6a 00 01 	mov	r10,262145
80003118:	30 0b       	mov	r11,0
8000311a:	fe 7c 54 00 	mov	r12,-44032
8000311e:	fe b0 f9 95 	rcall	80002448 <pwma_set_channels_value>
80003122:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
80003126:	e8 6a 00 01 	mov	r10,524289
8000312a:	30 0b       	mov	r11,0
8000312c:	fe 7c 54 00 	mov	r12,-44032
80003130:	fe b0 f9 8c 	rcall	80002448 <pwma_set_channels_value>
80003134:	0f b8       	ld.ub	r8,r7[0x3]
	
	
	// Move Body Forward
	servos[1][0] += 8;
80003136:	2f 88       	sub	r8,-8
80003138:	5c 58       	castu.b	r8
8000313a:	10 99       	mov	r9,r8
	servos[3][0] -= 8;
	servos[5][0] -= 8;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
8000313c:	ae b8       	st.b	r7[0x3],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
	
	
	// Move Body Forward
	servos[1][0] += 8;
8000313e:	ef 38 00 09 	ld.ub	r8,r7[9]
	servos[3][0] -= 8;
80003142:	20 88       	sub	r8,8
80003144:	ef 68 00 09 	st.b	r7[9],r8
80003148:	ef 38 00 0f 	ld.ub	r8,r7[15]
	servos[5][0] -= 8;
8000314c:	20 88       	sub	r8,8
8000314e:	e0 6a 20 01 	mov	r10,8193
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
80003152:	ef 68 00 0f 	st.b	r7[15],r8
	
	
	// Move Body Forward
	servos[1][0] += 8;
	servos[3][0] -= 8;
	servos[5][0] -= 8;
80003156:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
80003158:	fe 7c 54 00 	mov	r12,-44032
8000315c:	fe b0 f9 76 	rcall	80002448 <pwma_set_channels_value>
80003160:	ef 39 00 09 	ld.ub	r9,r7[9]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
80003164:	30 1a       	mov	r10,1
80003166:	30 8b       	mov	r11,8
80003168:	fe 7c 54 00 	mov	r12,-44032
8000316c:	fe b0 f9 6e 	rcall	80002448 <pwma_set_channels_value>
80003170:	ef 39 00 0f 	ld.ub	r9,r7[15]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
80003174:	e2 6a 00 01 	mov	r10,131073
80003178:	30 0b       	mov	r11,0
8000317a:	fe 7c 54 00 	mov	r12,-44032
8000317e:	fe b0 f9 65 	rcall	80002448 <pwma_set_channels_value>
80003182:	0f 88       	ld.ub	r8,r7[0x0]
	
	// Move Legs Forward
	servos[0][0] -= 8;
80003184:	20 88       	sub	r8,8
80003186:	5c 58       	castu.b	r8
80003188:	10 99       	mov	r9,r8
	servos[2][0] -= 8;
	servos[4][0] += 8;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
8000318a:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
	
	// Move Legs Forward
	servos[0][0] -= 8;
8000318c:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] -= 8;
8000318e:	20 88       	sub	r8,8
80003190:	ae e8       	st.b	r7[0x6],r8
80003192:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] += 8;
80003196:	2f 88       	sub	r8,-8
80003198:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
8000319a:	ef 68 00 0c 	st.b	r7[12],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
	
	// Move Legs Forward
	servos[0][0] -= 8;
	servos[2][0] -= 8;
	servos[4][0] += 8;
8000319e:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
800031a0:	fe 7c 54 00 	mov	r12,-44032
800031a4:	fe b0 f9 52 	rcall	80002448 <pwma_set_channels_value>
800031a8:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
800031aa:	30 1a       	mov	r10,1
800031ac:	ea 1a 20 00 	orh	r10,0x2000
800031b0:	30 0b       	mov	r11,0
800031b2:	fe 7c 54 00 	mov	r12,-44032
800031b6:	fe b0 f9 49 	rcall	80002448 <pwma_set_channels_value>
800031ba:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
800031be:	30 1a       	mov	r10,1
800031c0:	30 4b       	mov	r11,4
800031c2:	fe 7c 54 00 	mov	r12,-44032
800031c6:	fe b0 f9 41 	rcall	80002448 <pwma_set_channels_value>
800031ca:	0f 98       	ld.ub	r8,r7[0x1]
	
	
	// Drop Legs
	servos[0][1] -= 6;
800031cc:	20 68       	sub	r8,6
800031ce:	5c 58       	castu.b	r8
800031d0:	10 99       	mov	r9,r8
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
800031d2:	ae 98       	st.b	r7[0x1],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	// Drop Legs
	servos[0][1] -= 6;
800031d4:	0f a8       	ld.ub	r8,r7[0x2]
	servos[0][2] -= 6;
800031d6:	20 68       	sub	r8,6
800031d8:	ae a8       	st.b	r7[0x2],r8
800031da:	0f f8       	ld.ub	r8,r7[0x7]
	servos[2][1] -= 6;
800031dc:	20 68       	sub	r8,6
800031de:	ae f8       	st.b	r7[0x7],r8
800031e0:	ef 38 00 08 	ld.ub	r8,r7[8]
	servos[2][2] -= 6;
800031e4:	20 68       	sub	r8,6
800031e6:	ef 68 00 08 	st.b	r7[8],r8
800031ea:	ef 38 00 0d 	ld.ub	r8,r7[13]
	servos[4][1] -= 6;
800031ee:	20 68       	sub	r8,6
800031f0:	ef 68 00 0d 	st.b	r7[13],r8
800031f4:	ef 38 00 0e 	ld.ub	r8,r7[14]
	servos[4][2] -= 6;
800031f8:	20 68       	sub	r8,6
800031fa:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
800031fc:	ea 1a 00 20 	orh	r10,0x20
80003200:	ef 68 00 0e 	st.b	r7[14],r8
	servos[0][1] -= 6;
	servos[0][2] -= 6;
	servos[2][1] -= 6;
	servos[2][2] -= 6;
	servos[4][1] -= 6;
	servos[4][2] -= 6;
80003204:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80003206:	fe 7c 54 00 	mov	r12,-44032
8000320a:	fe b0 f9 1f 	rcall	80002448 <pwma_set_channels_value>
8000320e:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80003210:	30 1a       	mov	r10,1
80003212:	ea 1a 00 10 	orh	r10,0x10
80003216:	30 0b       	mov	r11,0
80003218:	fe 7c 54 00 	mov	r12,-44032
8000321c:	fe b0 f9 16 	rcall	80002448 <pwma_set_channels_value>
80003220:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
80003222:	30 1a       	mov	r10,1
80003224:	ea 1a 40 00 	orh	r10,0x4000
80003228:	30 0b       	mov	r11,0
8000322a:	fe 7c 54 00 	mov	r12,-44032
8000322e:	fe b0 f9 0d 	rcall	80002448 <pwma_set_channels_value>
80003232:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
80003236:	30 1a       	mov	r10,1
80003238:	ea 1a 80 00 	orh	r10,0x8000
8000323c:	30 0b       	mov	r11,0
8000323e:	fe 7c 54 00 	mov	r12,-44032
80003242:	fe b0 f9 03 	rcall	80002448 <pwma_set_channels_value>
80003246:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
8000324a:	e4 6a 00 01 	mov	r10,262145
8000324e:	30 0b       	mov	r11,0
80003250:	fe 7c 54 00 	mov	r12,-44032
80003254:	fe b0 f8 fa 	rcall	80002448 <pwma_set_channels_value>
80003258:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
8000325c:	e8 6a 00 01 	mov	r10,524289
80003260:	30 0b       	mov	r11,0
80003262:	fe 7c 54 00 	mov	r12,-44032
80003266:	fe b0 f8 f1 	rcall	80002448 <pwma_set_channels_value>
8000326a:	0f 88       	ld.ub	r8,r7[0x0]
	
	
	// Move Body Forward
	servos[0][0] += 4;
8000326c:	2f c8       	sub	r8,-4
8000326e:	5c 58       	castu.b	r8
80003270:	10 99       	mov	r9,r8
	servos[2][0] += 4;
	servos[4][0] -= 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80003272:	ae 88       	st.b	r7[0x0],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
	
	
	// Move Body Forward
	servos[0][0] += 4;
80003274:	0f e8       	ld.ub	r8,r7[0x6]
	servos[2][0] += 4;
80003276:	2f c8       	sub	r8,-4
80003278:	ae e8       	st.b	r7[0x6],r8
8000327a:	ef 38 00 0c 	ld.ub	r8,r7[12]
	servos[4][0] -= 4;
8000327e:	20 48       	sub	r8,4
80003280:	30 1a       	mov	r10,1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80003282:	ef 68 00 0c 	st.b	r7[12],r8
	
	
	// Move Body Forward
	servos[0][0] += 4;
	servos[2][0] += 4;
	servos[4][0] -= 4;
80003286:	30 2b       	mov	r11,2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
80003288:	fe 7c 54 00 	mov	r12,-44032
8000328c:	fe b0 f8 de 	rcall	80002448 <pwma_set_channels_value>
80003290:	0f e9       	ld.ub	r9,r7[0x6]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80003292:	30 1a       	mov	r10,1
80003294:	ea 1a 20 00 	orh	r10,0x2000
80003298:	30 0b       	mov	r11,0
8000329a:	fe 7c 54 00 	mov	r12,-44032
8000329e:	fe b0 f8 d5 	rcall	80002448 <pwma_set_channels_value>
800032a2:	ef 39 00 0c 	ld.ub	r9,r7[12]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
800032a6:	30 1a       	mov	r10,1
800032a8:	30 4b       	mov	r11,4
800032aa:	fe 7c 54 00 	mov	r12,-44032
800032ae:	fe b0 f8 cd 	rcall	80002448 <pwma_set_channels_value>
800032b2:	0f b8       	ld.ub	r8,r7[0x3]
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
800032b4:	20 48       	sub	r8,4
800032b6:	5c 58       	castu.b	r8
800032b8:	10 99       	mov	r9,r8
	servos[3][0] += 4;
	servos[5][0] += 4;
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
800032ba:	ae b8       	st.b	r7[0x3],r8
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
800032bc:	ef 38 00 09 	ld.ub	r8,r7[9]
	servos[3][0] += 4;
800032c0:	2f c8       	sub	r8,-4
800032c2:	ef 68 00 09 	st.b	r7[9],r8
800032c6:	ef 38 00 0f 	ld.ub	r8,r7[15]
	servos[5][0] += 4;
800032ca:	2f c8       	sub	r8,-4
800032cc:	e0 6a 20 01 	mov	r10,8193
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
800032d0:	ef 68 00 0f 	st.b	r7[15],r8
	
	
	// Move Legs Forward
	servos[1][0] -= 4;
	servos[3][0] += 4;
	servos[5][0] += 4;
800032d4:	30 0b       	mov	r11,0
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
800032d6:	fe 7c 54 00 	mov	r12,-44032
800032da:	fe b0 f8 b7 	rcall	80002448 <pwma_set_channels_value>
800032de:	ef 39 00 09 	ld.ub	r9,r7[9]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
800032e2:	30 1a       	mov	r10,1
800032e4:	30 8b       	mov	r11,8
800032e6:	fe 7c 54 00 	mov	r12,-44032
800032ea:	fe b0 f8 af 	rcall	80002448 <pwma_set_channels_value>
800032ee:	ef 39 00 0f 	ld.ub	r9,r7[15]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
800032f2:	e2 6a 00 01 	mov	r10,131073
800032f6:	30 0b       	mov	r11,0
800032f8:	fe 7c 54 00 	mov	r12,-44032
800032fc:	fe b0 f8 a6 	rcall	80002448 <pwma_set_channels_value>
80003300:	e3 cd 80 80 	ldm	sp++,r7,pc

80003304 <main>:
	
}
80003304:	eb cd 40 80 	pushm	r7,lr
80003308:	32 0c       	mov	r12,32
8000330a:	fe b0 f8 5b 	rcall	800023c0 <pcl_configure_clocks>
8000330e:	30 4b       	mov	r11,4

int main(void)
{
	init_system();
	
	gpio_enable_module_pin(PWMA09_GPIO, PWM09_PWM_FUNCTION);
80003310:	30 9c       	mov	r12,9
80003312:	fe b0 f6 c1 	rcall	80002094 <gpio_enable_module_pin>
80003316:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA11_GPIO, PWM11_PWM_FUNCTION);
80003318:	30 bc       	mov	r12,11
8000331a:	fe b0 f6 bd 	rcall	80002094 <gpio_enable_module_pin>
8000331e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA12_GPIO, PWM12_PWM_FUNCTION);
80003320:	30 cc       	mov	r12,12
80003322:	fe b0 f6 b9 	rcall	80002094 <gpio_enable_module_pin>
80003326:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA13_GPIO, PWM13_PWM_FUNCTION);
80003328:	30 dc       	mov	r12,13
8000332a:	fe b0 f6 b5 	rcall	80002094 <gpio_enable_module_pin>
8000332e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA15_GPIO, PWM15_PWM_FUNCTION);
80003330:	30 fc       	mov	r12,15
80003332:	fe b0 f6 b1 	rcall	80002094 <gpio_enable_module_pin>
80003336:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA16_GPIO, PWM16_PWM_FUNCTION);
80003338:	31 0c       	mov	r12,16
8000333a:	fe b0 f6 ad 	rcall	80002094 <gpio_enable_module_pin>
8000333e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA17_GPIO, PWM17_PWM_FUNCTION);
80003340:	31 1c       	mov	r12,17
80003342:	fe b0 f6 a9 	rcall	80002094 <gpio_enable_module_pin>
80003346:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA18_GPIO, PWM18_PWM_FUNCTION);
80003348:	31 2c       	mov	r12,18
8000334a:	fe b0 f6 a5 	rcall	80002094 <gpio_enable_module_pin>
8000334e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA19_GPIO, PWM19_PWM_FUNCTION);
80003350:	31 3c       	mov	r12,19
80003352:	fe b0 f6 a1 	rcall	80002094 <gpio_enable_module_pin>
80003356:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA20_GPIO, PWM20_PWM_FUNCTION);
80003358:	31 4c       	mov	r12,20
8000335a:	fe b0 f6 9d 	rcall	80002094 <gpio_enable_module_pin>
8000335e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA21_GPIO, PWM21_PWM_FUNCTION);
80003360:	31 5c       	mov	r12,21
80003362:	fe b0 f6 99 	rcall	80002094 <gpio_enable_module_pin>
80003366:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA22_GPIO, PWM22_PWM_FUNCTION);
80003368:	31 6c       	mov	r12,22
8000336a:	fe b0 f6 95 	rcall	80002094 <gpio_enable_module_pin>
8000336e:	30 4b       	mov	r11,4
	
	
	gpio_enable_module_pin(PWMA23_GPIO, PWM23_PWM_FUNCTION);
80003370:	32 0c       	mov	r12,32
80003372:	fe b0 f6 91 	rcall	80002094 <gpio_enable_module_pin>
80003376:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA25_GPIO, PWM25_PWM_FUNCTION);
80003378:	32 2c       	mov	r12,34
8000337a:	fe b0 f6 8d 	rcall	80002094 <gpio_enable_module_pin>
8000337e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA26_GPIO, PWM26_PWM_FUNCTION);
80003380:	32 3c       	mov	r12,35
80003382:	fe b0 f6 89 	rcall	80002094 <gpio_enable_module_pin>
80003386:	30 4b       	mov	r11,4
	
	//gpio_enable_module_pin(PWMA27_GPIO, PWM27_PWM_FUNCTION);
	
	gpio_enable_module_pin(PWMA28_GPIO, PWM28_PWM_FUNCTION);
80003388:	32 5c       	mov	r12,37
8000338a:	fe b0 f6 85 	rcall	80002094 <gpio_enable_module_pin>
8000338e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA29_GPIO, PWM29_PWM_FUNCTION);
80003390:	32 6c       	mov	r12,38
80003392:	fe b0 f6 81 	rcall	80002094 <gpio_enable_module_pin>
80003396:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA30_GPIO, PWM30_PWM_FUNCTION);
80003398:	32 7c       	mov	r12,39
8000339a:	fe b0 f6 7d 	rcall	80002094 <gpio_enable_module_pin>
8000339e:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA31_GPIO, PWM31_PWM_FUNCTION);
800033a0:	32 8c       	mov	r12,40
800033a2:	fe b0 f6 79 	rcall	80002094 <gpio_enable_module_pin>
800033a6:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA32_GPIO, PWM32_PWM_FUNCTION);
800033a8:	32 9c       	mov	r12,41
800033aa:	fe b0 f6 75 	rcall	80002094 <gpio_enable_module_pin>
800033ae:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA33_GPIO, PWM33_PWM_FUNCTION);
800033b0:	32 ac       	mov	r12,42
800033b2:	fe b0 f6 71 	rcall	80002094 <gpio_enable_module_pin>
800033b6:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA34_GPIO, PWM34_PWM_FUNCTION);
800033b8:	32 bc       	mov	r12,43
800033ba:	fe b0 f6 6d 	rcall	80002094 <gpio_enable_module_pin>
800033be:	30 4b       	mov	r11,4
	gpio_enable_module_pin(PWMA35_GPIO, PWM35_PWM_FUNCTION);
800033c0:	32 cc       	mov	r12,44
800033c2:	fe b0 f6 69 	rcall	80002094 <gpio_enable_module_pin>
800033c6:	fe b0 f8 aa 	rcall	8000251a <scif_start_rc32k>
	
	
	scif_start_rc32k();
800033ca:	30 29       	mov	r9,2
	scif_gc_setup(  AVR32_PM_GCLK_PWMA, 
800033cc:	30 1a       	mov	r10,1
800033ce:	30 9b       	mov	r11,9
800033d0:	30 3c       	mov	r12,3
800033d2:	fe b0 f8 4d 	rcall	8000246c <scif_gc_setup>
800033d6:	30 3c       	mov	r12,3
					SCIF_GCCTRL_RC32K, 
					true,              
					2);                 
	scif_gc_enable(AVR32_PM_GCLK_PWMA);
800033d8:	fe b0 f8 93 	rcall	800024fe <scif_gc_enable>
800033dc:	30 08       	mov	r8,0
	
	
	pwma_config_and_enable( &AVR32_PWMA, (PWM_CH1)
800033de:	e0 69 00 ff 	mov	r9,255
800033e2:	e0 6a ba 01 	mov	r10,47617
800033e6:	ea 1a fe ff 	orh	r10,0xfeff
800033ea:	30 fb       	mov	r11,15
800033ec:	fe 7c 54 00 	mov	r12,-44032
800033f0:	fe b0 f8 16 	rcall	8000241c <pwma_config_and_enable>
800033f4:	30 1a       	mov	r10,1
	delay_init(sysclk_get_cpu_hz());
	
	// Center all motors
	// ----------------------------------------------------
	// Update Leg 1
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH4), servos[0][0]);
800033f6:	30 c7       	mov	r7,12
800033f8:	30 2b       	mov	r11,2
800033fa:	0f 89       	ld.ub	r9,r7[0x0]
800033fc:	fe 7c 54 00 	mov	r12,-44032
80003400:	fe b0 f8 24 	rcall	80002448 <pwma_set_channels_value>
80003404:	0f 99       	ld.ub	r9,r7[0x1]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH5), servos[0][1]);
80003406:	30 1a       	mov	r10,1
80003408:	ea 1a 00 20 	orh	r10,0x20
8000340c:	30 0b       	mov	r11,0
8000340e:	fe 7c 54 00 	mov	r12,-44032
80003412:	fe b0 f8 1b 	rcall	80002448 <pwma_set_channels_value>
80003416:	0f a9       	ld.ub	r9,r7[0x2]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH6), servos[0][2]);
80003418:	30 1a       	mov	r10,1
8000341a:	ea 1a 00 10 	orh	r10,0x10
8000341e:	30 0b       	mov	r11,0
80003420:	fe 7c 54 00 	mov	r12,-44032
80003424:	fe b0 f8 12 	rcall	80002448 <pwma_set_channels_value>
80003428:	0f b9       	ld.ub	r9,r7[0x3]
	
	// Update Leg 2
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH7), servos[1][0]);
8000342a:	e0 6a 20 01 	mov	r10,8193
8000342e:	30 0b       	mov	r11,0
80003430:	fe 7c 54 00 	mov	r12,-44032
80003434:	fe b0 f8 0a 	rcall	80002448 <pwma_set_channels_value>
80003438:	0f c9       	ld.ub	r9,r7[0x4]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH8), servos[1][1]);
8000343a:	e0 6a 08 01 	mov	r10,2049
8000343e:	30 0b       	mov	r11,0
80003440:	fe 7c 54 00 	mov	r12,-44032
80003444:	fe b0 f8 02 	rcall	80002448 <pwma_set_channels_value>
80003448:	0f d9       	ld.ub	r9,r7[0x5]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH9), servos[1][2]);
8000344a:	30 1a       	mov	r10,1
8000344c:	30 1b       	mov	r11,1
8000344e:	fe 7c 54 00 	mov	r12,-44032
80003452:	fe b0 f7 fb 	rcall	80002448 <pwma_set_channels_value>
80003456:	0f e9       	ld.ub	r9,r7[0x6]
	
	// Update Leg 3
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH10), servos[2][0]);
80003458:	30 1a       	mov	r10,1
8000345a:	ea 1a 20 00 	orh	r10,0x2000
8000345e:	30 0b       	mov	r11,0
80003460:	fe 7c 54 00 	mov	r12,-44032
80003464:	fe b0 f7 f2 	rcall	80002448 <pwma_set_channels_value>
80003468:	0f f9       	ld.ub	r9,r7[0x7]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH11), servos[2][1]);
8000346a:	30 1a       	mov	r10,1
8000346c:	ea 1a 40 00 	orh	r10,0x4000
80003470:	30 0b       	mov	r11,0
80003472:	fe 7c 54 00 	mov	r12,-44032
80003476:	fe b0 f7 e9 	rcall	80002448 <pwma_set_channels_value>
8000347a:	ef 39 00 08 	ld.ub	r9,r7[8]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH12), servos[2][2]);
8000347e:	30 1a       	mov	r10,1
80003480:	ea 1a 80 00 	orh	r10,0x8000
80003484:	30 0b       	mov	r11,0
80003486:	fe 7c 54 00 	mov	r12,-44032
8000348a:	fe b0 f7 df 	rcall	80002448 <pwma_set_channels_value>
8000348e:	ef 39 00 09 	ld.ub	r9,r7[9]
	
	// Update Leg 4
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH16), servos[3][0]);
80003492:	30 1a       	mov	r10,1
80003494:	30 8b       	mov	r11,8
80003496:	fe 7c 54 00 	mov	r12,-44032
8000349a:	fe b0 f7 d7 	rcall	80002448 <pwma_set_channels_value>
8000349e:	ef 39 00 0a 	ld.ub	r9,r7[10]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH17), servos[3][1]);
800034a2:	e0 6a 02 01 	mov	r10,513
800034a6:	30 0b       	mov	r11,0
800034a8:	fe 7c 54 00 	mov	r12,-44032
800034ac:	fe b0 f7 ce 	rcall	80002448 <pwma_set_channels_value>
800034b0:	ef 39 00 0b 	ld.ub	r9,r7[11]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH18), servos[3][2]);
800034b4:	e0 6a 10 01 	mov	r10,4097
800034b8:	30 0b       	mov	r11,0
800034ba:	fe 7c 54 00 	mov	r12,-44032
800034be:	fe b0 f7 c5 	rcall	80002448 <pwma_set_channels_value>
800034c2:	ef 39 00 0c 	ld.ub	r9,r7[12]
	
	// Update Leg 5
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH19), servos[4][0]);
800034c6:	30 1a       	mov	r10,1
800034c8:	30 4b       	mov	r11,4
800034ca:	fe 7c 54 00 	mov	r12,-44032
800034ce:	fe b0 f7 bd 	rcall	80002448 <pwma_set_channels_value>
800034d2:	ef 39 00 0d 	ld.ub	r9,r7[13]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH20), servos[4][1]);
800034d6:	e4 6a 00 01 	mov	r10,262145
800034da:	30 0b       	mov	r11,0
800034dc:	fe 7c 54 00 	mov	r12,-44032
800034e0:	fe b0 f7 b4 	rcall	80002448 <pwma_set_channels_value>
800034e4:	ef 39 00 0e 	ld.ub	r9,r7[14]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH21), servos[4][2]);
800034e8:	e8 6a 00 01 	mov	r10,524289
800034ec:	30 0b       	mov	r11,0
800034ee:	fe 7c 54 00 	mov	r12,-44032
800034f2:	fe b0 f7 ab 	rcall	80002448 <pwma_set_channels_value>
800034f6:	ef 39 00 0f 	ld.ub	r9,r7[15]
	
	// Update Leg 6
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH22), servos[5][0]);
800034fa:	e2 6a 00 01 	mov	r10,131073
800034fe:	30 0b       	mov	r11,0
80003500:	fe 7c 54 00 	mov	r12,-44032
80003504:	fe b0 f7 a2 	rcall	80002448 <pwma_set_channels_value>
80003508:	ef 39 00 10 	ld.ub	r9,r7[16]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
8000350c:	e0 7a 00 01 	mov	r10,65537
80003510:	30 0b       	mov	r11,0
80003512:	fe 7c 54 00 	mov	r12,-44032
80003516:	fe b0 f7 99 	rcall	80002448 <pwma_set_channels_value>
8000351a:	ef 39 00 11 	ld.ub	r9,r7[17]
	pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
8000351e:	e0 6a 80 01 	mov	r10,32769
80003522:	30 0b       	mov	r11,0
80003524:	fe 7c 54 00 	mov	r12,-44032
80003528:	fe b0 f7 90 	rcall	80002448 <pwma_set_channels_value>
8000352c:	fe b0 fc ca 	rcall	80002ec0 <walk_forward>
		pwma_set_channels_value(&AVR32_PWMA, (PWM_CH23), servos[5][1]);
		pwma_set_channels_value(&AVR32_PWMA, (PWM_CH24), servos[5][2]);
		*/
		
		
		walk_forward();
80003530:	fe b0 fc c8 	rcall	80002ec0 <walk_forward>
		walk_forward();
80003534:	fe b0 fc c6 	rcall	80002ec0 <walk_forward>
		walk_forward();
80003538:	fe b0 fb 3a 	rcall	80002bac <turn_left>
		turn_left();
8000353c:	fe b0 fb 38 	rcall	80002bac <turn_left>
		turn_left();
80003540:	fe b0 fb 36 	rcall	80002bac <turn_left>
		turn_left();
80003544:	fe b0 fb 34 	rcall	80002bac <turn_left>
		turn_left();
80003548:	fe b0 fb 32 	rcall	80002bac <turn_left>
		turn_left();
8000354c:	fe b0 fc ba 	rcall	80002ec0 <walk_forward>
		walk_forward();
80003550:	fe b0 fc b8 	rcall	80002ec0 <walk_forward>
		walk_forward();
80003554:	fe b0 fc b6 	rcall	80002ec0 <walk_forward>
		walk_forward();
80003558:	fe b0 f9 a0 	rcall	80002898 <turn_right>
		turn_right();
8000355c:	fe b0 f9 9e 	rcall	80002898 <turn_right>
		turn_right();
80003560:	fe b0 f9 9c 	rcall	80002898 <turn_right>
		turn_right();
80003564:	fe b0 f9 9a 	rcall	80002898 <turn_right>
		turn_right();
80003568:	fe b0 f9 98 	rcall	80002898 <turn_right>
		turn_right();
8000356c:	ce 0b       	rjmp	8000352c <main+0x228>
8000356e:	d7 03       	nop

80003570 <__avr32_udiv64>:
80003570:	d4 31       	pushm	r0-r7,lr
80003572:	1a 97       	mov	r7,sp
80003574:	20 2d       	sub	sp,8
80003576:	10 9e       	mov	lr,r8
80003578:	12 95       	mov	r5,r9
8000357a:	14 96       	mov	r6,r10
8000357c:	58 09       	cp.w	r9,0
8000357e:	c4 91       	brne	80003610 <__avr32_udiv64+0xa0>
80003580:	16 38       	cp.w	r8,r11
80003582:	e0 88 00 57 	brls	80003630 <__avr32_udiv64+0xc0>
80003586:	f0 08 12 00 	clz	r8,r8
8000358a:	c0 d0       	breq	800035a4 <__avr32_udiv64+0x34>
8000358c:	f6 08 09 4b 	lsl	r11,r11,r8
80003590:	f0 09 11 20 	rsub	r9,r8,32
80003594:	fc 08 09 4e 	lsl	lr,lr,r8
80003598:	f4 09 0a 49 	lsr	r9,r10,r9
8000359c:	f4 08 09 46 	lsl	r6,r10,r8
800035a0:	f3 eb 10 0b 	or	r11,r9,r11
800035a4:	fc 05 16 10 	lsr	r5,lr,0x10
800035a8:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
800035ac:	f6 05 0d 0a 	divu	r10,r11,r5
800035b0:	ec 08 16 10 	lsr	r8,r6,0x10
800035b4:	14 99       	mov	r9,r10
800035b6:	f1 eb 11 08 	or	r8,r8,r11<<0x10
800035ba:	b9 3a       	mul	r10,r12
800035bc:	10 3a       	cp.w	r10,r8
800035be:	e0 88 00 0c 	brls	800035d6 <__avr32_udiv64+0x66>
800035c2:	20 19       	sub	r9,1
800035c4:	1c 08       	add	r8,lr
800035c6:	10 3e       	cp.w	lr,r8
800035c8:	e0 8b 00 07 	brhi	800035d6 <__avr32_udiv64+0x66>
800035cc:	10 3a       	cp.w	r10,r8
800035ce:	f7 b9 0b 01 	subhi	r9,1
800035d2:	f1 de eb 08 	addhi	r8,r8,lr
800035d6:	f0 0a 01 0b 	sub	r11,r8,r10
800035da:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
800035de:	f6 05 0d 0a 	divu	r10,r11,r5
800035e2:	ed eb 11 06 	or	r6,r6,r11<<0x10
800035e6:	14 98       	mov	r8,r10
800035e8:	f4 0c 02 4c 	mul	r12,r10,r12
800035ec:	0c 3c       	cp.w	r12,r6
800035ee:	e0 88 00 0a 	brls	80003602 <__avr32_udiv64+0x92>
800035f2:	20 18       	sub	r8,1
800035f4:	1c 06       	add	r6,lr
800035f6:	0c 3e       	cp.w	lr,r6
800035f8:	e0 8b 00 05 	brhi	80003602 <__avr32_udiv64+0x92>
800035fc:	0c 3c       	cp.w	r12,r6
800035fe:	f7 b8 0b 01 	subhi	r8,1
80003602:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
80003606:	30 0c       	mov	r12,0
80003608:	16 9a       	mov	r10,r11
8000360a:	18 9b       	mov	r11,r12
8000360c:	2f ed       	sub	sp,-8
8000360e:	d8 32       	popm	r0-r7,pc
80003610:	16 39       	cp.w	r9,r11
80003612:	e0 8b 00 51 	brhi	800036b4 <__avr32_udiv64+0x144>
80003616:	f2 0c 12 00 	clz	r12,r9
8000361a:	c5 31       	brne	800036c0 <__avr32_udiv64+0x150>
8000361c:	14 38       	cp.w	r8,r10
8000361e:	5f 89       	srls	r9
80003620:	16 35       	cp.w	r5,r11
80003622:	5f 38       	srlo	r8
80003624:	10 49       	or	r9,r8
80003626:	f8 09 18 00 	cp.b	r9,r12
8000362a:	c4 50       	breq	800036b4 <__avr32_udiv64+0x144>
8000362c:	30 1b       	mov	r11,1
8000362e:	c4 58       	rjmp	800036b8 <__avr32_udiv64+0x148>
80003630:	58 08       	cp.w	r8,0
80003632:	c0 51       	brne	8000363c <__avr32_udiv64+0xcc>
80003634:	30 19       	mov	r9,1
80003636:	f2 08 0d 08 	divu	r8,r9,r8
8000363a:	10 9e       	mov	lr,r8
8000363c:	fc 08 12 00 	clz	r8,lr
80003640:	e0 81 00 91 	brne	80003762 <__avr32_udiv64+0x1f2>
80003644:	1c 1b       	sub	r11,lr
80003646:	fc 05 16 10 	lsr	r5,lr,0x10
8000364a:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000364e:	30 1c       	mov	r12,1
80003650:	f6 05 0d 0a 	divu	r10,r11,r5
80003654:	ec 08 16 10 	lsr	r8,r6,0x10
80003658:	f4 09 02 43 	mul	r3,r10,r9
8000365c:	f1 eb 11 08 	or	r8,r8,r11<<0x10
80003660:	14 9b       	mov	r11,r10
80003662:	10 33       	cp.w	r3,r8
80003664:	e0 88 00 0c 	brls	8000367c <__avr32_udiv64+0x10c>
80003668:	20 1b       	sub	r11,1
8000366a:	1c 08       	add	r8,lr
8000366c:	10 3e       	cp.w	lr,r8
8000366e:	e0 8b 00 07 	brhi	8000367c <__avr32_udiv64+0x10c>
80003672:	10 33       	cp.w	r3,r8
80003674:	f7 bb 0b 01 	subhi	r11,1
80003678:	f1 de eb 08 	addhi	r8,r8,lr
8000367c:	f0 03 01 03 	sub	r3,r8,r3
80003680:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003684:	e6 05 0d 02 	divu	r2,r3,r5
80003688:	ed e3 11 06 	or	r6,r6,r3<<0x10
8000368c:	04 98       	mov	r8,r2
8000368e:	e4 09 02 49 	mul	r9,r2,r9
80003692:	0c 39       	cp.w	r9,r6
80003694:	e0 88 00 0a 	brls	800036a8 <__avr32_udiv64+0x138>
80003698:	20 18       	sub	r8,1
8000369a:	1c 06       	add	r6,lr
8000369c:	0c 3e       	cp.w	lr,r6
8000369e:	e0 8b 00 05 	brhi	800036a8 <__avr32_udiv64+0x138>
800036a2:	0c 39       	cp.w	r9,r6
800036a4:	f7 b8 0b 01 	subhi	r8,1
800036a8:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
800036ac:	16 9a       	mov	r10,r11
800036ae:	18 9b       	mov	r11,r12
800036b0:	2f ed       	sub	sp,-8
800036b2:	d8 32       	popm	r0-r7,pc
800036b4:	30 0b       	mov	r11,0
800036b6:	16 9c       	mov	r12,r11
800036b8:	16 9a       	mov	r10,r11
800036ba:	18 9b       	mov	r11,r12
800036bc:	2f ed       	sub	sp,-8
800036be:	d8 32       	popm	r0-r7,pc
800036c0:	f2 0c 09 45 	lsl	r5,r9,r12
800036c4:	f8 0e 11 20 	rsub	lr,r12,32
800036c8:	f0 0c 09 43 	lsl	r3,r8,r12
800036cc:	f4 0e 0a 46 	lsr	r6,r10,lr
800036d0:	f0 0e 0a 48 	lsr	r8,r8,lr
800036d4:	f6 0e 0a 4e 	lsr	lr,r11,lr
800036d8:	0a 48       	or	r8,r5
800036da:	f0 01 16 10 	lsr	r1,r8,0x10
800036de:	fc 01 0d 04 	divu	r4,lr,r1
800036e2:	ee e5 ff f8 	st.d	r7[-8],r4
800036e6:	f6 0c 09 49 	lsl	r9,r11,r12
800036ea:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
800036ee:	ed e9 10 09 	or	r9,r6,r9
800036f2:	08 96       	mov	r6,r4
800036f4:	f2 0e 16 10 	lsr	lr,r9,0x10
800036f8:	ee f4 ff f8 	ld.w	r4,r7[-8]
800036fc:	ec 05 02 4b 	mul	r11,r6,r5
80003700:	fd e4 11 0e 	or	lr,lr,r4<<0x10
80003704:	1c 3b       	cp.w	r11,lr
80003706:	e0 88 00 07 	brls	80003714 <__avr32_udiv64+0x1a4>
8000370a:	20 16       	sub	r6,1
8000370c:	10 0e       	add	lr,r8
8000370e:	1c 38       	cp.w	r8,lr
80003710:	e0 88 00 6d 	brls	800037ea <__avr32_udiv64+0x27a>
80003714:	16 1e       	sub	lr,r11
80003716:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000371a:	fc 01 0d 00 	divu	r0,lr,r1
8000371e:	f3 e1 11 09 	or	r9,r9,r1<<0x10
80003722:	00 9b       	mov	r11,r0
80003724:	e0 05 02 4e 	mul	lr,r0,r5
80003728:	12 3e       	cp.w	lr,r9
8000372a:	e0 88 00 07 	brls	80003738 <__avr32_udiv64+0x1c8>
8000372e:	20 1b       	sub	r11,1
80003730:	10 09       	add	r9,r8
80003732:	12 38       	cp.w	r8,r9
80003734:	e0 88 00 55 	brls	800037de <__avr32_udiv64+0x26e>
80003738:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
8000373c:	1c 19       	sub	r9,lr
8000373e:	f6 03 06 42 	mulu.d	r2,r11,r3
80003742:	06 39       	cp.w	r9,r3
80003744:	c0 93       	brcs	80003756 <__avr32_udiv64+0x1e6>
80003746:	5f 09       	sreq	r9
80003748:	f4 0c 09 4c 	lsl	r12,r10,r12
8000374c:	04 3c       	cp.w	r12,r2
8000374e:	5f 38       	srlo	r8
80003750:	f3 e8 00 08 	and	r8,r9,r8
80003754:	c0 20       	breq	80003758 <__avr32_udiv64+0x1e8>
80003756:	20 1b       	sub	r11,1
80003758:	30 0c       	mov	r12,0
8000375a:	16 9a       	mov	r10,r11
8000375c:	18 9b       	mov	r11,r12
8000375e:	2f ed       	sub	sp,-8
80003760:	d8 32       	popm	r0-r7,pc
80003762:	f6 08 09 49 	lsl	r9,r11,r8
80003766:	fc 08 09 4e 	lsl	lr,lr,r8
8000376a:	f0 01 11 20 	rsub	r1,r8,32
8000376e:	fc 05 16 10 	lsr	r5,lr,0x10
80003772:	f4 01 0a 42 	lsr	r2,r10,r1
80003776:	f6 01 0a 41 	lsr	r1,r11,r1
8000377a:	12 42       	or	r2,r9
8000377c:	e2 05 0d 00 	divu	r0,r1,r5
80003780:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
80003784:	e4 06 16 10 	lsr	r6,r2,0x10
80003788:	00 93       	mov	r3,r0
8000378a:	ed e1 11 06 	or	r6,r6,r1<<0x10
8000378e:	e0 09 02 4c 	mul	r12,r0,r9
80003792:	0c 3c       	cp.w	r12,r6
80003794:	e0 88 00 07 	brls	800037a2 <__avr32_udiv64+0x232>
80003798:	20 13       	sub	r3,1
8000379a:	1c 06       	add	r6,lr
8000379c:	0c 3e       	cp.w	lr,r6
8000379e:	e0 88 00 2c 	brls	800037f6 <__avr32_udiv64+0x286>
800037a2:	ec 0c 01 01 	sub	r1,r6,r12
800037a6:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
800037aa:	e2 05 0d 00 	divu	r0,r1,r5
800037ae:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800037b2:	00 9c       	mov	r12,r0
800037b4:	e0 09 02 41 	mul	r1,r0,r9
800037b8:	16 31       	cp.w	r1,r11
800037ba:	e0 88 00 0c 	brls	800037d2 <__avr32_udiv64+0x262>
800037be:	20 1c       	sub	r12,1
800037c0:	1c 0b       	add	r11,lr
800037c2:	16 3e       	cp.w	lr,r11
800037c4:	e0 8b 00 07 	brhi	800037d2 <__avr32_udiv64+0x262>
800037c8:	16 31       	cp.w	r1,r11
800037ca:	f7 bc 0b 01 	subhi	r12,1
800037ce:	f7 de eb 0b 	addhi	r11,r11,lr
800037d2:	f4 08 09 46 	lsl	r6,r10,r8
800037d6:	02 1b       	sub	r11,r1
800037d8:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
800037dc:	c3 ab       	rjmp	80003650 <__avr32_udiv64+0xe0>
800037de:	12 3e       	cp.w	lr,r9
800037e0:	f3 d8 eb 09 	addhi	r9,r9,r8
800037e4:	f7 bb 0b 01 	subhi	r11,1
800037e8:	ca 8b       	rjmp	80003738 <__avr32_udiv64+0x1c8>
800037ea:	1c 3b       	cp.w	r11,lr
800037ec:	f7 b6 0b 01 	subhi	r6,1
800037f0:	fd d8 eb 0e 	addhi	lr,lr,r8
800037f4:	c9 0b       	rjmp	80003714 <__avr32_udiv64+0x1a4>
800037f6:	0c 3c       	cp.w	r12,r6
800037f8:	f7 b3 0b 01 	subhi	r3,1
800037fc:	ed de eb 06 	addhi	r6,r6,lr
80003800:	cd 1b       	rjmp	800037a2 <__avr32_udiv64+0x232>

Disassembly of section .exception:

80003a00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80003a00:	c0 08       	rjmp	80003a00 <_evba>
	...

80003a04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80003a04:	c0 08       	rjmp	80003a04 <_handle_TLB_Multiple_Hit>
	...

80003a08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80003a08:	c0 08       	rjmp	80003a08 <_handle_Bus_Error_Data_Fetch>
	...

80003a0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80003a0c:	c0 08       	rjmp	80003a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80003a10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80003a10:	c0 08       	rjmp	80003a10 <_handle_NMI>
	...

80003a14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80003a14:	c0 08       	rjmp	80003a14 <_handle_Instruction_Address>
	...

80003a18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80003a18:	c0 08       	rjmp	80003a18 <_handle_ITLB_Protection>
	...

80003a1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80003a1c:	c0 08       	rjmp	80003a1c <_handle_Breakpoint>
	...

80003a20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80003a20:	c0 08       	rjmp	80003a20 <_handle_Illegal_Opcode>
	...

80003a24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80003a24:	c0 08       	rjmp	80003a24 <_handle_Unimplemented_Instruction>
	...

80003a28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80003a28:	c0 08       	rjmp	80003a28 <_handle_Privilege_Violation>
	...

80003a2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80003a2c:	c0 08       	rjmp	80003a2c <_handle_Floating_Point>
	...

80003a30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80003a30:	c0 08       	rjmp	80003a30 <_handle_Coprocessor_Absent>
	...

80003a34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80003a34:	c0 08       	rjmp	80003a34 <_handle_Data_Address_Read>
	...

80003a38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80003a38:	c0 08       	rjmp	80003a38 <_handle_Data_Address_Write>
	...

80003a3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80003a3c:	c0 08       	rjmp	80003a3c <_handle_DTLB_Protection_Read>
	...

80003a40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80003a40:	c0 08       	rjmp	80003a40 <_handle_DTLB_Protection_Write>
	...

80003a44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80003a44:	c0 08       	rjmp	80003a44 <_handle_DTLB_Modified>
	...

80003a50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80003a50:	c0 08       	rjmp	80003a50 <_handle_ITLB_Miss>
	...

80003a60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80003a60:	c0 08       	rjmp	80003a60 <_handle_DTLB_Miss_Read>
	...

80003a70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80003a70:	c0 08       	rjmp	80003a70 <_handle_DTLB_Miss_Write>
	...

80003b00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80003b00:	c0 08       	rjmp	80003b00 <_handle_Supervisor_Call>
80003b02:	d7 03       	nop

80003b04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80003b04:	30 0c       	mov	r12,0
80003b06:	fe b0 f3 15 	rcall	80002130 <_get_interrupt_handler>
80003b0a:	58 0c       	cp.w	r12,0
80003b0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80003b10:	d6 03       	rete

80003b12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80003b12:	30 1c       	mov	r12,1
80003b14:	fe b0 f3 0e 	rcall	80002130 <_get_interrupt_handler>
80003b18:	58 0c       	cp.w	r12,0
80003b1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80003b1e:	d6 03       	rete

80003b20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80003b20:	30 2c       	mov	r12,2
80003b22:	fe b0 f3 07 	rcall	80002130 <_get_interrupt_handler>
80003b26:	58 0c       	cp.w	r12,0
80003b28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80003b2c:	d6 03       	rete

80003b2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80003b2e:	30 3c       	mov	r12,3
80003b30:	fe b0 f3 00 	rcall	80002130 <_get_interrupt_handler>
80003b34:	58 0c       	cp.w	r12,0
80003b36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80003b3a:	d6 03       	rete
80003b3c:	d7 03       	nop
80003b3e:	d7 03       	nop
80003b40:	d7 03       	nop
80003b42:	d7 03       	nop
80003b44:	d7 03       	nop
80003b46:	d7 03       	nop
80003b48:	d7 03       	nop
80003b4a:	d7 03       	nop
80003b4c:	d7 03       	nop
80003b4e:	d7 03       	nop
80003b50:	d7 03       	nop
80003b52:	d7 03       	nop
80003b54:	d7 03       	nop
80003b56:	d7 03       	nop
80003b58:	d7 03       	nop
80003b5a:	d7 03       	nop
80003b5c:	d7 03       	nop
80003b5e:	d7 03       	nop
80003b60:	d7 03       	nop
80003b62:	d7 03       	nop
80003b64:	d7 03       	nop
80003b66:	d7 03       	nop
80003b68:	d7 03       	nop
80003b6a:	d7 03       	nop
80003b6c:	d7 03       	nop
80003b6e:	d7 03       	nop
80003b70:	d7 03       	nop
80003b72:	d7 03       	nop
80003b74:	d7 03       	nop
80003b76:	d7 03       	nop
80003b78:	d7 03       	nop
80003b7a:	d7 03       	nop
80003b7c:	d7 03       	nop
80003b7e:	d7 03       	nop
80003b80:	d7 03       	nop
80003b82:	d7 03       	nop
80003b84:	d7 03       	nop
80003b86:	d7 03       	nop
80003b88:	d7 03       	nop
80003b8a:	d7 03       	nop
80003b8c:	d7 03       	nop
80003b8e:	d7 03       	nop
80003b90:	d7 03       	nop
80003b92:	d7 03       	nop
80003b94:	d7 03       	nop
80003b96:	d7 03       	nop
80003b98:	d7 03       	nop
80003b9a:	d7 03       	nop
80003b9c:	d7 03       	nop
80003b9e:	d7 03       	nop
80003ba0:	d7 03       	nop
80003ba2:	d7 03       	nop
80003ba4:	d7 03       	nop
80003ba6:	d7 03       	nop
80003ba8:	d7 03       	nop
80003baa:	d7 03       	nop
80003bac:	d7 03       	nop
80003bae:	d7 03       	nop
80003bb0:	d7 03       	nop
80003bb2:	d7 03       	nop
80003bb4:	d7 03       	nop
80003bb6:	d7 03       	nop
80003bb8:	d7 03       	nop
80003bba:	d7 03       	nop
80003bbc:	d7 03       	nop
80003bbe:	d7 03       	nop
80003bc0:	d7 03       	nop
80003bc2:	d7 03       	nop
80003bc4:	d7 03       	nop
80003bc6:	d7 03       	nop
80003bc8:	d7 03       	nop
80003bca:	d7 03       	nop
80003bcc:	d7 03       	nop
80003bce:	d7 03       	nop
80003bd0:	d7 03       	nop
80003bd2:	d7 03       	nop
80003bd4:	d7 03       	nop
80003bd6:	d7 03       	nop
80003bd8:	d7 03       	nop
80003bda:	d7 03       	nop
80003bdc:	d7 03       	nop
80003bde:	d7 03       	nop
80003be0:	d7 03       	nop
80003be2:	d7 03       	nop
80003be4:	d7 03       	nop
80003be6:	d7 03       	nop
80003be8:	d7 03       	nop
80003bea:	d7 03       	nop
80003bec:	d7 03       	nop
80003bee:	d7 03       	nop
80003bf0:	d7 03       	nop
80003bf2:	d7 03       	nop
80003bf4:	d7 03       	nop
80003bf6:	d7 03       	nop
80003bf8:	d7 03       	nop
80003bfa:	d7 03       	nop
80003bfc:	d7 03       	nop
80003bfe:	d7 03       	nop
