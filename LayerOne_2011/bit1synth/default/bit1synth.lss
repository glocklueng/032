
bit1synth.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  00001260  000012f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001260  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000058  00800122  00800122  00001316  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00001316  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000022f  00000000  00000000  00001336  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000701  00000000  00000000  00001565  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001f2  00000000  00000000  00001c66  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000073c  00000000  00000000  00001e58  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000e0  00000000  00000000  00002594  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002df  00000000  00000000  00002674  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000169  00000000  00000000  00002953  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9d 04 	jmp	0x93a	; 0x93a <__ctors_end>
       4:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
       8:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
       c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      10:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      14:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      18:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      1c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      20:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      24:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      28:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      2c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      30:	0c 94 73 05 	jmp	0xae6	; 0xae6 <__vector_12>
      34:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      38:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      3c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      40:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      44:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      48:	0c 94 4a 05 	jmp	0xa94	; 0xa94 <__vector_18>
      4c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      50:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      54:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      58:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      5c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      60:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      64:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      68:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      6c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      70:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      74:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      78:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      7c:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      80:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      84:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>
      88:	0c 94 ba 04 	jmp	0x974	; 0x974 <__bad_interrupt>

0000008c <freqvals>:
      8c:	ff ff ff ff ff ff ff ff ff ff 61 fd 28 ef ff ff     ..........a.(...
      9c:	ff ff ff ff ff ff ff ff ff ff 61 fd 28 ef bc e1     ..........a.(...
      ac:	10 d5 1b c9 d1 bd 2a b3 1c a9 9e 9f a8 96 34 8e     ......*.......4.
      bc:	38 86 b0 7e 94 77 dd 70 88 6a 8d 64 e8 5e 95 59     8..~.w.p.j.d.^.Y
      cc:	8d 54 ce 4f 54 4b 19 47 1c 43 57 3f c9 3b 6e 38     .T.OTK.G.CW?.;n8
      dc:	43 35 46 32 74 2f ca 2c 46 2a e7 27 a9 25 8c 23     C5F2t/.,F*.'.%.#
      ec:	8d 21 ab 1f e4 1d 37 1c a1 1a 23 19 b9 17 64 16     .!....7...#...d.
      fc:	23 15 f3 13 d4 12 c6 11 c6 10 d5 0f f2 0e 1b 0e     #...............
     10c:	50 0d 91 0c dc 0b 32 0b 91 0a f9 09 6a 09 e2 08     P.....2.....j...
     11c:	63 08 ea 07 78 07 0d 07 a8 06 48 06 ee 05 98 05     c...x.....H.....
     12c:	48 05 fc 04 b4 04 71 04 31 04 f5 03 bc 03 86 03     H.....q.1.......
     13c:	53 03 23 03 f6 02 cc 02 a3 02 7d 02 5a 02 38 02     S.#.......}.Z.8.
     14c:	18 02 fa 01 dd 01 c2 01 a9 01 91 01 7b 01 65 01     ............{.e.
     15c:	51 01 3e 01 2c 01 1b 01 0b 01 fc 00 ee 00 e1 00     Q.>.,...........
     16c:	d4 00 c8 00 bd 00 b2 00 a8 00 9f 00 96 00 8d 00     ................
     17c:	85 00 7e 00 77 00 70 00 6a 00 64 00 5e 00 59 00     ..~.w.p.j.d.^.Y.

0000018c <daft>:
     18c:	90 3e 7f 80 3e 00 90 36 7f 80 36 00 90 3b 7f 80     .>..>..6..6..;..
     19c:	3b 00 90 36 7f 80 36 00 90 3e 7f 80 3e 00 90 36     ;..6..6..>..>..6
     1ac:	7f 80 36 00 90 3b 7f 80 3b 00 90 36 7f 80 36 00     ..6..;..;..6..6.
     1bc:	90 3e 7f 80 3e 00 90 36 7f 80 36 00 90 3b 7f 80     .>..>..6..6..;..
     1cc:	3b 00 90 36 7f 80 36 00 90 3e 7f 80 3e 00 90 36     ;..6..6..>..>..6
     1dc:	7f 80 36 00 90 3b 7f 80 3b 00 90 36 7f 80 36 00     ..6..;..;..6..6.
     1ec:	90 3e 7f 80 3e 00 90 38 7f 80 38 00 90 3b 7f 80     .>..>..8..8..;..
     1fc:	3b 00 90 38 7f 80 38 00 90 3e 7f 80 3e 00 90 38     ;..8..8..>..>..8
     20c:	7f 80 38 00 90 3b 7f 80 3b 00 90 38 7f 80 38 00     ..8..;..;..8..8.
     21c:	90 3e 7f 80 3e 00 90 38 7f 80 38 00 90 3b 7f 80     .>..>..8..8..;..
     22c:	3b 00 90 38 7f 80 38 00 90 3e 7f 80 3e 00 90 38     ;..8..8..>..>..8
     23c:	7f 80 38 00 90 3b 7f 80 3b 00 90 38 7f 80 38 00     ..8..;..;..8..8.
     24c:	90 43 7f 80 43 00 90 3b 7f 80 3b 00 90 40 7f 80     .C..C..;..;..@..
     25c:	40 00 90 3b 7f 80 3b 00 90 43 7f 80 43 00 90 3b     @..;..;..C..C..;
     26c:	7f 80 3b 00 90 40 7f 80 40 00 90 3b 7f 80 3b 00     ..;..@..@..;..;.
     27c:	90 43 7f 80 43 00 90 3b 7f 80 3b 00 90 40 7f 80     .C..C..;..;..@..
     28c:	40 00 90 3b 7f 80 3b 00 90 43 7f 80 43 00 90 3b     @..;..;..C..C..;
     29c:	7f 80 3b 00 90 40 7f 80 40 00 90 3b 7f 80 3b 00     ..;..@..@..;..;.
     2ac:	90 40 7f 80 40 00 90 39 7f 80 39 00 90 3d 7f 80     .@..@..9..9..=..
     2bc:	3d 00 90 39 7f 80 39 00 90 40 7f 80 40 00 90 39     =..9..9..@..@..9
     2cc:	7f 80 39 00 90 3d 7f 80 3d 00 90 39 7f 80 39 00     ..9..=..=..9..9.
     2dc:	90 40 7f 80 40 00 90 39 7f 80 39 00 90 3d 7f 80     .@..@..9..9..=..
     2ec:	3d 00 90 39 7f 80 39 00 90 40 7f 80 40 00 90 39     =..9..9..@..@..9
     2fc:	7f 80 39 00 90 3d 7f 80 3d 00 90 39 7f 80 39 00     ..9..=..=..9..9.
     30c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     31c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     32c:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     33c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     34c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     35c:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     36c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     37c:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     38c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     39c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     3ac:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     3bc:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     3cc:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     3dc:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     3ec:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     3fc:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     40c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     41c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     42c:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     43c:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     44c:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     45c:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     46c:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     47c:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     48c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     49c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     4ac:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     4bc:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     4cc:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     4dc:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     4ec:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     4fc:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     50c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     51c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     52c:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     53c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     54c:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     55c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     56c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     57c:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     58c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     59c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     5ac:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     5bc:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     5cc:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     5dc:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     5ec:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     5fc:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     60c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     61c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     62c:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     63c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     64c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     65c:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     66c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     67c:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     68c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     69c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     6ac:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     6bc:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     6cc:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     6dc:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     6ec:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     6fc:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     70c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     71c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     72c:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     73c:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     74c:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     75c:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     76c:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     77c:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     78c:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     79c:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     7ac:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     7bc:	90 4a 7f 80 4a 00 90 42 7f 80 42 00 90 47 7f 80     .J..J..B..B..G..
     7cc:	47 00 90 42 7f 80 42 00 90 4a 7f 80 4a 00 90 42     G..B..B..J..J..B
     7dc:	7f 80 42 00 90 47 7f 80 47 00 90 42 7f 80 42 00     ..B..G..G..B..B.
     7ec:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     7fc:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     80c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     81c:	90 4a 7f 80 4a 00 90 44 7f 80 44 00 90 47 7f 80     .J..J..D..D..G..
     82c:	47 00 90 44 7f 80 44 00 90 4a 7f 80 4a 00 90 44     G..D..D..J..J..D
     83c:	7f 80 44 00 90 47 7f 80 47 00 90 44 7f 80 44 00     ..D..G..G..D..D.
     84c:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     85c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     86c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     87c:	90 4f 7f 80 4f 00 90 47 7f 80 47 00 90 4c 7f 80     .O..O..G..G..L..
     88c:	4c 00 90 47 7f 80 47 00 90 4f 7f 80 4f 00 90 47     L..G..G..O..O..G
     89c:	7f 80 47 00 90 4c 7f 80 4c 00 90 47 7f 80 47 00     ..G..L..L..G..G.
     8ac:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     8bc:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     8cc:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     8dc:	90 4c 7f 80 4c 00 90 45 7f 80 45 00 90 49 7f 80     .L..L..E..E..I..
     8ec:	49 00 90 45 7f 80 45 00 90 4c 7f 80 4c 00 90 45     I..E..E..L..L..E
     8fc:	7f 80 45 00 90 49 7f 80 49 00 90 45 7f 80 45 00     ..E..I..I..E..E.
     90c:	90 4a 7f 80 4a 00                                   .J..J.

00000912 <led30>:
     912:	00 7f 03 1f 03 c7 03 f1 01 3f 03 4f 03 d3 03 f4     .........?.O....
     922:	00 f7 00 df 03 37 03 cd 01 f3 01 cf 03 73 03 dc     .....7.......s..
     932:	01 fc 00 fd 03 7c 03 3d                             .....|.=

0000093a <__ctors_end>:
     93a:	11 24       	eor	r1, r1
     93c:	1f be       	out	0x3f, r1	; 63
     93e:	cf ef       	ldi	r28, 0xFF	; 255
     940:	d0 e1       	ldi	r29, 0x10	; 16
     942:	de bf       	out	0x3e, r29	; 62
     944:	cd bf       	out	0x3d, r28	; 61

00000946 <__do_copy_data>:
     946:	11 e0       	ldi	r17, 0x01	; 1
     948:	a0 e0       	ldi	r26, 0x00	; 0
     94a:	b1 e0       	ldi	r27, 0x01	; 1
     94c:	e0 e6       	ldi	r30, 0x60	; 96
     94e:	f2 e1       	ldi	r31, 0x12	; 18
     950:	02 c0       	rjmp	.+4      	; 0x956 <.do_copy_data_start>

00000952 <.do_copy_data_loop>:
     952:	05 90       	lpm	r0, Z+
     954:	0d 92       	st	X+, r0

00000956 <.do_copy_data_start>:
     956:	a2 32       	cpi	r26, 0x22	; 34
     958:	b1 07       	cpc	r27, r17
     95a:	d9 f7       	brne	.-10     	; 0x952 <.do_copy_data_loop>

0000095c <__do_clear_bss>:
     95c:	11 e0       	ldi	r17, 0x01	; 1
     95e:	a2 e2       	ldi	r26, 0x22	; 34
     960:	b1 e0       	ldi	r27, 0x01	; 1
     962:	01 c0       	rjmp	.+2      	; 0x966 <.do_clear_bss_start>

00000964 <.do_clear_bss_loop>:
     964:	1d 92       	st	X+, r1

00000966 <.do_clear_bss_start>:
     966:	aa 37       	cpi	r26, 0x7A	; 122
     968:	b1 07       	cpc	r27, r17
     96a:	e1 f7       	brne	.-8      	; 0x964 <.do_clear_bss_loop>
     96c:	0e 94 88 08 	call	0x1110	; 0x1110 <main>
     970:	0c 94 2e 09 	jmp	0x125c	; 0x125c <_exit>

00000974 <__bad_interrupt>:
     974:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000978 <lfsr_rand>:

// faster noise generator than rand()
uint16_t lfsr_rand()
{
  static uint16_t lfsr = 0xACE1u;
  lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xB400u);
     978:	80 91 1f 01 	lds	r24, 0x011F
     97c:	90 91 20 01 	lds	r25, 0x0120
     980:	9c 01       	movw	r18, r24
     982:	21 70       	andi	r18, 0x01	; 1
     984:	30 70       	andi	r19, 0x00	; 0
     986:	30 95       	com	r19
     988:	21 95       	neg	r18
     98a:	3f 4f       	sbci	r19, 0xFF	; 255
     98c:	20 70       	andi	r18, 0x00	; 0
     98e:	34 7b       	andi	r19, 0xB4	; 180
     990:	96 95       	lsr	r25
     992:	87 95       	ror	r24
     994:	28 27       	eor	r18, r24
     996:	39 27       	eor	r19, r25
     998:	30 93 20 01 	sts	0x0120, r19
     99c:	20 93 1f 01 	sts	0x011F, r18
  return lfsr;
}
     9a0:	c9 01       	movw	r24, r18
     9a2:	08 95       	ret

000009a4 <midi_init>:
	// set baud rate

#define BAUD 31250

#include <util/setbaud.h>
	UBRR0H = UBRRH_VALUE;
     9a4:	10 92 90 00 	sts	0x0090, r1
	UBRR0L = UBRRL_VALUE;
     9a8:	8f e1       	ldi	r24, 0x1F	; 31
     9aa:	89 b9       	out	0x09, r24	; 9
#if USE_2X
	UCSR0A |= _BV(U2X0);
#else
	UCSR0A &= ~_BV(U2X0);
     9ac:	59 98       	cbi	0x0b, 1	; 11
#endif

	// enable rx, turn on interrupt
	// 8 data bits, no parity, 1 stop bit
	UCSR0B = _BV(RXCIE0) | _BV(RXEN0);
     9ae:	80 e9       	ldi	r24, 0x90	; 144
     9b0:	8a b9       	out	0x0a, r24	; 10
	UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
     9b2:	86 e0       	ldi	r24, 0x06	; 6
     9b4:	80 93 95 00 	sts	0x0095, r24
}
     9b8:	08 95       	ret

000009ba <processMessage>:
	processMessage( lastByte); 

}

void processMessage( unsigned char byte) 
{
     9ba:	98 2f       	mov	r25, r24
  
  // is it a status byte?
  if (byte >= 0x80)
     9bc:	87 ff       	sbrs	r24, 7
     9be:	20 c0       	rjmp	.+64     	; 0xa00 <processMessage+0x46>
  {
    usemidi = 1;
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	80 93 60 01 	sts	0x0160, r24
    switch (byte)
     9c6:	9c 3f       	cpi	r25, 0xFC	; 252
     9c8:	a1 f0       	breq	.+40     	; 0x9f2 <processMessage+0x38>
     9ca:	9d 3f       	cpi	r25, 0xFD	; 253
     9cc:	28 f4       	brcc	.+10     	; 0x9d8 <processMessage+0x1e>
     9ce:	90 38       	cpi	r25, 0x80	; 128
     9d0:	49 f0       	breq	.+18     	; 0x9e4 <processMessage+0x2a>
     9d2:	90 39       	cpi	r25, 0x90	; 144
     9d4:	81 f4       	brne	.+32     	; 0x9f6 <processMessage+0x3c>
     9d6:	09 c0       	rjmp	.+18     	; 0x9ea <processMessage+0x30>
     9d8:	9e 3f       	cpi	r25, 0xFE	; 254
     9da:	09 f4       	brne	.+2      	; 0x9de <processMessage+0x24>
     9dc:	5a c0       	rjmp	.+180    	; 0xa92 <processMessage+0xd8>
     9de:	9f 3f       	cpi	r25, 0xFF	; 255
     9e0:	51 f4       	brne	.+20     	; 0x9f6 <processMessage+0x3c>
     9e2:	07 c0       	rjmp	.+14     	; 0x9f2 <processMessage+0x38>
    {
      case 0x80:
        midimode = MIDI_NOTE_OFF;
     9e4:	80 93 62 01 	sts	0x0162, r24
     9e8:	2e c0       	rjmp	.+92     	; 0xa46 <processMessage+0x8c>
        midibytesleft = 2;
        break;
      case 0x90:
        midimode = MIDI_NOTE_ON;
     9ea:	82 e0       	ldi	r24, 0x02	; 2
     9ec:	80 93 62 01 	sts	0x0162, r24
     9f0:	2b c0       	rjmp	.+86     	; 0xa48 <processMessage+0x8e>
        break;
      case 0xFE: // active sense
        break;
      case 0xFC: // stop
      case 0xFF: // reset
        noteon = 0;
     9f2:	10 92 61 01 	sts	0x0161, r1
      default:
        midimode = MIDI_OTHER;
     9f6:	10 92 62 01 	sts	0x0162, r1
        midibytesleft = 0;
     9fa:	10 92 63 01 	sts	0x0163, r1
     9fe:	08 95       	ret
    }
  }
  else
  {
    // save the second and third bytes
    if (midibytesleft > 0)
     a00:	20 91 63 01 	lds	r18, 0x0163
     a04:	12 16       	cp	r1, r18
     a06:	4c f4       	brge	.+18     	; 0xa1a <processMessage+0x60>
    {
      midibuffer[0] = midibuffer[1];
     a08:	80 91 79 01 	lds	r24, 0x0179
     a0c:	80 93 78 01 	sts	0x0178, r24
      midibuffer[1] = byte;
     a10:	90 93 79 01 	sts	0x0179, r25
      midibytesleft--;
     a14:	21 50       	subi	r18, 0x01	; 1
     a16:	20 93 63 01 	sts	0x0163, r18
    }

    // got all bytes; parse message
    if (midibytesleft <= 0)
     a1a:	80 91 63 01 	lds	r24, 0x0163
     a1e:	18 16       	cp	r1, r24
     a20:	c4 f1       	brlt	.+112    	; 0xa92 <processMessage+0xd8>
    {
      uint8_t note = midibuffer[0];
     a22:	20 91 78 01 	lds	r18, 0x0178
      switch (midimode)
     a26:	80 91 62 01 	lds	r24, 0x0162
     a2a:	81 30       	cpi	r24, 0x01	; 1
     a2c:	19 f0       	breq	.+6      	; 0xa34 <processMessage+0x7a>
     a2e:	82 30       	cpi	r24, 0x02	; 2
     a30:	81 f5       	brne	.+96     	; 0xa92 <processMessage+0xd8>
     a32:	0d c0       	rjmp	.+26     	; 0xa4e <processMessage+0x94>
      {
        case MIDI_NOTE_OFF:
          if (note == midilastnote)
     a34:	80 91 0b 01 	lds	r24, 0x010B
     a38:	28 17       	cp	r18, r24
     a3a:	29 f4       	brne	.+10     	; 0xa46 <processMessage+0x8c>
          {
            noteon = 0;
     a3c:	10 92 61 01 	sts	0x0161, r1
            midilastnote = 0xFF;
     a40:	8f ef       	ldi	r24, 0xFF	; 255
     a42:	80 93 0b 01 	sts	0x010B, r24
          }
          midibytesleft = 2; // receive more note off events
     a46:	82 e0       	ldi	r24, 0x02	; 2
     a48:	80 93 63 01 	sts	0x0163, r24
     a4c:	08 95       	ret
          break;
        case MIDI_NOTE_ON:
          // turn note off if velocity is zero
          if (midibuffer[1] == 0 && note == midilastnote)
     a4e:	80 91 79 01 	lds	r24, 0x0179
     a52:	88 23       	and	r24, r24
     a54:	51 f4       	brne	.+20     	; 0xa6a <processMessage+0xb0>
     a56:	80 91 0b 01 	lds	r24, 0x010B
     a5a:	28 17       	cp	r18, r24
     a5c:	b9 f4       	brne	.+46     	; 0xa8c <processMessage+0xd2>
          {
            noteon = 0;
     a5e:	10 92 61 01 	sts	0x0161, r1
            midilastnote = 0xFF;
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	80 93 0b 01 	sts	0x010B, r24
     a68:	11 c0       	rjmp	.+34     	; 0xa8c <processMessage+0xd2>
          }
          else if (midibuffer[1] != 0)
          {
            noteon = 1;
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	80 93 61 01 	sts	0x0161, r24
            pitch = pgm_read_word(freqvals+note);
     a70:	e2 2f       	mov	r30, r18
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	ee 0f       	add	r30, r30
     a76:	ff 1f       	adc	r31, r31
     a78:	e4 57       	subi	r30, 0x74	; 116
     a7a:	ff 4f       	sbci	r31, 0xFF	; 255
     a7c:	85 91       	lpm	r24, Z+
     a7e:	94 91       	lpm	r25, Z+
     a80:	90 93 09 01 	sts	0x0109, r25
     a84:	80 93 08 01 	sts	0x0108, r24
            midilastnote = note;
     a88:	20 93 0b 01 	sts	0x010B, r18
          }
          midibytesleft = 2; // receive more note on events
     a8c:	82 e0       	ldi	r24, 0x02	; 2
     a8e:	80 93 63 01 	sts	0x0163, r24
     a92:	08 95       	ret

00000a94 <__vector_18>:

static volatile unsigned char lastByte;

// midi receive interrupt
ISR(USART0_RX_vect)
{
     a94:	1f 92       	push	r1
     a96:	0f 92       	push	r0
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	0f 92       	push	r0
     a9c:	11 24       	eor	r1, r1
     a9e:	2f 93       	push	r18
     aa0:	3f 93       	push	r19
     aa2:	4f 93       	push	r20
     aa4:	5f 93       	push	r21
     aa6:	6f 93       	push	r22
     aa8:	7f 93       	push	r23
     aaa:	8f 93       	push	r24
     aac:	9f 93       	push	r25
     aae:	af 93       	push	r26
     ab0:	bf 93       	push	r27
     ab2:	ef 93       	push	r30
     ab4:	ff 93       	push	r31
	lastByte = UDR0 ;
     ab6:	8c b1       	in	r24, 0x0c	; 12
     ab8:	80 93 75 01 	sts	0x0175, r24

	processMessage( lastByte); 
     abc:	80 91 75 01 	lds	r24, 0x0175
     ac0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <processMessage>

}
     ac4:	ff 91       	pop	r31
     ac6:	ef 91       	pop	r30
     ac8:	bf 91       	pop	r27
     aca:	af 91       	pop	r26
     acc:	9f 91       	pop	r25
     ace:	8f 91       	pop	r24
     ad0:	7f 91       	pop	r23
     ad2:	6f 91       	pop	r22
     ad4:	5f 91       	pop	r21
     ad6:	4f 91       	pop	r20
     ad8:	3f 91       	pop	r19
     ada:	2f 91       	pop	r18
     adc:	0f 90       	pop	r0
     ade:	0f be       	out	0x3f, r0	; 63
     ae0:	0f 90       	pop	r0
     ae2:	1f 90       	pop	r1
     ae4:	18 95       	reti

00000ae6 <__vector_12>:
}


// timer interrupt; update audio out
ISR(TIMER1_COMPA_vect)
{
     ae6:	1f 92       	push	r1
     ae8:	0f 92       	push	r0
     aea:	0f b6       	in	r0, 0x3f	; 63
     aec:	0f 92       	push	r0
     aee:	11 24       	eor	r1, r1
     af0:	2f 93       	push	r18
     af2:	3f 93       	push	r19
     af4:	4f 93       	push	r20
     af6:	5f 93       	push	r21
     af8:	6f 93       	push	r22
     afa:	7f 93       	push	r23
     afc:	8f 93       	push	r24
     afe:	9f 93       	push	r25
     b00:	af 93       	push	r26
     b02:	bf 93       	push	r27
     b04:	ef 93       	push	r30
     b06:	ff 93       	push	r31




  uint8_t shiftout;
  if (wavenum != 7)
     b08:	80 91 5f 01 	lds	r24, 0x015F
     b0c:	87 30       	cpi	r24, 0x07	; 7
     b0e:	e1 f0       	breq	.+56     	; 0xb48 <__vector_12+0x62>
  {
    shiftout = waveform & 1;
     b10:	20 91 76 01 	lds	r18, 0x0176
     b14:	30 91 77 01 	lds	r19, 0x0177
    waveform >>= 1;
     b18:	80 91 76 01 	lds	r24, 0x0176
     b1c:	90 91 77 01 	lds	r25, 0x0177
     b20:	96 95       	lsr	r25
     b22:	87 95       	ror	r24
     b24:	90 93 77 01 	sts	0x0177, r25
     b28:	80 93 76 01 	sts	0x0176, r24
    if (shiftout)
     b2c:	32 2f       	mov	r19, r18
     b2e:	31 70       	andi	r19, 0x01	; 1
     b30:	20 ff       	sbrs	r18, 0
     b32:	0e c0       	rjmp	.+28     	; 0xb50 <__vector_12+0x6a>
      waveform |= (1 << 15);
     b34:	80 91 76 01 	lds	r24, 0x0176
     b38:	90 91 77 01 	lds	r25, 0x0177
     b3c:	90 68       	ori	r25, 0x80	; 128
     b3e:	90 93 77 01 	sts	0x0177, r25
     b42:	80 93 76 01 	sts	0x0176, r24
     b46:	04 c0       	rjmp	.+8      	; 0xb50 <__vector_12+0x6a>
  }
  else
  {
    shiftout = lfsr_rand() & 1;
     b48:	0e 94 bc 04 	call	0x978	; 0x978 <lfsr_rand>
     b4c:	38 2f       	mov	r19, r24
     b4e:	31 70       	andi	r19, 0x01	; 1
  }

  // apply envelope
  shiftout &= envval;
     b50:	20 91 0c 01 	lds	r18, 0x010C
  
  // mute if note off
  shiftout &= noteon;
     b54:	90 91 61 01 	lds	r25, 0x0161

//	if(noteon)
//		PORTC 	= waveform;

	if (noteon) {
     b58:	80 91 61 01 	lds	r24, 0x0161
     b5c:	88 23       	and	r24, r24
     b5e:	49 f0       	breq	.+18     	; 0xb72 <__vector_12+0x8c>
  {
    shiftout = lfsr_rand() & 1;
  }

  // apply envelope
  shiftout &= envval;
     b60:	92 23       	and	r25, r18
//		PORTC 	= waveform;

	if (noteon) {

  // update audio pin (we're using all pins for more volume ), using  0xff-knobs[PITCH_KNOB].val; will let you use the pitch slider as volume
  if (shiftout) 
     b62:	93 23       	and	r25, r19
     b64:	29 f0       	breq	.+10     	; 0xb70 <__vector_12+0x8a>
    PORTC = 0xff-knobs[PITCH_KNOB].val;
     b66:	80 91 3b 01 	lds	r24, 0x013B
     b6a:	80 95       	com	r24
     b6c:	85 bb       	out	0x15, r24	; 21
     b6e:	01 c0       	rjmp	.+2      	; 0xb72 <__vector_12+0x8c>
  else
	PORTC =0;
     b70:	15 ba       	out	0x15, r1	; 21
}
}
     b72:	ff 91       	pop	r31
     b74:	ef 91       	pop	r30
     b76:	bf 91       	pop	r27
     b78:	af 91       	pop	r26
     b7a:	9f 91       	pop	r25
     b7c:	8f 91       	pop	r24
     b7e:	7f 91       	pop	r23
     b80:	6f 91       	pop	r22
     b82:	5f 91       	pop	r21
     b84:	4f 91       	pop	r20
     b86:	3f 91       	pop	r19
     b88:	2f 91       	pop	r18
     b8a:	0f 90       	pop	r0
     b8c:	0f be       	out	0x3f, r0	; 63
     b8e:	0f 90       	pop	r0
     b90:	1f 90       	pop	r1
     b92:	18 95       	reti

00000b94 <read_adc>:

// sample an ADC channel
void read_adc(knob_t *k)
{
     b94:	fc 01       	movw	r30, r24

  uint16_t val = ADCL;
     b96:	34 b1       	in	r19, 0x04	; 4
  val += (ADCH << 8);
     b98:	25 b1       	in	r18, 0x05	; 5
  // accumulate value
  k->accum += val;
     b9a:	92 2f       	mov	r25, r18
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	83 0f       	add	r24, r19
     ba0:	91 1d       	adc	r25, r1
     ba2:	9c 01       	movw	r18, r24
     ba4:	40 e0       	ldi	r20, 0x00	; 0
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	82 81       	ldd	r24, Z+2	; 0x02
     baa:	93 81       	ldd	r25, Z+3	; 0x03
     bac:	a4 81       	ldd	r26, Z+4	; 0x04
     bae:	b5 81       	ldd	r27, Z+5	; 0x05
     bb0:	28 0f       	add	r18, r24
     bb2:	39 1f       	adc	r19, r25
     bb4:	4a 1f       	adc	r20, r26
     bb6:	5b 1f       	adc	r21, r27
     bb8:	22 83       	std	Z+2, r18	; 0x02
     bba:	33 83       	std	Z+3, r19	; 0x03
     bbc:	44 83       	std	Z+4, r20	; 0x04
     bbe:	55 83       	std	Z+5, r21	; 0x05

  // take average when timer overflows
  if (adctimer == 0)
     bc0:	80 91 22 01 	lds	r24, 0x0122
     bc4:	88 23       	and	r24, r24
     bc6:	69 f4       	brne	.+26     	; 0xbe2 <read_adc+0x4e>
  {
    k->val = k->accum / NUM_ADC_SAMPLES;
     bc8:	75 e0       	ldi	r23, 0x05	; 5
     bca:	56 95       	lsr	r21
     bcc:	47 95       	ror	r20
     bce:	37 95       	ror	r19
     bd0:	27 95       	ror	r18
     bd2:	7a 95       	dec	r23
     bd4:	d1 f7       	brne	.-12     	; 0xbca <read_adc+0x36>
     bd6:	31 83       	std	Z+1, r19	; 0x01
     bd8:	20 83       	st	Z, r18
    k->accum = 0;
     bda:	12 82       	std	Z+2, r1	; 0x02
     bdc:	13 82       	std	Z+3, r1	; 0x03
     bde:	14 82       	std	Z+4, r1	; 0x04
     be0:	15 82       	std	Z+5, r1	; 0x05
     be2:	08 95       	ret

00000be4 <update_pitch>:

// set new pitch
void update_pitch()
{
  uint16_t newpitch = (usemidi) ? pitch-(lfoval*4U)
                                : 200U + ((pitch-lfoval)*4U);
     be4:	80 91 60 01 	lds	r24, 0x0160
     be8:	40 91 67 01 	lds	r20, 0x0167
     bec:	50 91 68 01 	lds	r21, 0x0168
     bf0:	20 91 08 01 	lds	r18, 0x0108
     bf4:	30 91 09 01 	lds	r19, 0x0109
     bf8:	88 23       	and	r24, r24
     bfa:	39 f0       	breq	.+14     	; 0xc0a <update_pitch+0x26>
     bfc:	44 0f       	add	r20, r20
     bfe:	55 1f       	adc	r21, r21
     c00:	44 0f       	add	r20, r20
     c02:	55 1f       	adc	r21, r21
     c04:	24 1b       	sub	r18, r20
     c06:	35 0b       	sbc	r19, r21
     c08:	08 c0       	rjmp	.+16     	; 0xc1a <update_pitch+0x36>
     c0a:	2e 5c       	subi	r18, 0xCE	; 206
     c0c:	3f 4f       	sbci	r19, 0xFF	; 255
     c0e:	24 1b       	sub	r18, r20
     c10:	35 0b       	sbc	r19, r21
     c12:	22 0f       	add	r18, r18
     c14:	33 1f       	adc	r19, r19
     c16:	22 0f       	add	r18, r18
     c18:	33 1f       	adc	r19, r19
  if (newpitch != outpitch)
     c1a:	80 91 64 01 	lds	r24, 0x0164
     c1e:	90 91 65 01 	lds	r25, 0x0165
     c22:	28 17       	cp	r18, r24
     c24:	39 07       	cpc	r19, r25
     c26:	69 f0       	breq	.+26     	; 0xc42 <update_pitch+0x5e>
  {
    outpitch = newpitch;
     c28:	30 93 65 01 	sts	0x0165, r19
     c2c:	20 93 64 01 	sts	0x0164, r18
    if (TCNT1 > outpitch)
     c30:	8c b5       	in	r24, 0x2c	; 44
     c32:	9d b5       	in	r25, 0x2d	; 45
     c34:	28 17       	cp	r18, r24
     c36:	39 07       	cpc	r19, r25
     c38:	10 f4       	brcc	.+4      	; 0xc3e <update_pitch+0x5a>
      TCNT1 = 0;
     c3a:	1d bc       	out	0x2d, r1	; 45
     c3c:	1c bc       	out	0x2c, r1	; 44
    OCR1A = outpitch;
     c3e:	3b bd       	out	0x2b, r19	; 43
     c40:	2a bd       	out	0x2a, r18	; 42
     c42:	08 95       	ret

00000c44 <update_lfo>:
}

// update lfo state
void update_lfo()
{
  switch (lfowavenum)
     c44:	40 91 0a 01 	lds	r20, 0x010A
     c48:	43 30       	cpi	r20, 0x03	; 3
     c4a:	09 f4       	brne	.+2      	; 0xc4e <update_lfo+0xa>
     c4c:	5a c0       	rjmp	.+180    	; 0xd02 <update_lfo+0xbe>
     c4e:	44 30       	cpi	r20, 0x04	; 4
     c50:	60 f4       	brcc	.+24     	; 0xc6a <update_lfo+0x26>
     c52:	41 30       	cpi	r20, 0x01	; 1
     c54:	b1 f1       	breq	.+108    	; 0xcc2 <update_lfo+0x7e>
     c56:	20 91 66 01 	lds	r18, 0x0166
     c5a:	60 91 69 01 	lds	r22, 0x0169
     c5e:	70 91 6a 01 	lds	r23, 0x016A
     c62:	42 30       	cpi	r20, 0x02	; 2
     c64:	08 f0       	brcs	.+2      	; 0xc68 <update_lfo+0x24>
     c66:	41 c0       	rjmp	.+130    	; 0xcea <update_lfo+0xa6>
     c68:	0d c0       	rjmp	.+26     	; 0xc84 <update_lfo+0x40>
     c6a:	45 30       	cpi	r20, 0x05	; 5
     c6c:	09 f4       	brne	.+2      	; 0xc70 <update_lfo+0x2c>
     c6e:	6c c0       	rjmp	.+216    	; 0xd48 <update_lfo+0x104>
     c70:	45 30       	cpi	r20, 0x05	; 5
     c72:	08 f4       	brcc	.+2      	; 0xc76 <update_lfo+0x32>
     c74:	53 c0       	rjmp	.+166    	; 0xd1c <update_lfo+0xd8>
     c76:	46 30       	cpi	r20, 0x06	; 6
     c78:	09 f4       	brne	.+2      	; 0xc7c <update_lfo+0x38>
     c7a:	85 c0       	rjmp	.+266    	; 0xd86 <update_lfo+0x142>
     c7c:	47 30       	cpi	r20, 0x07	; 7
     c7e:	09 f0       	breq	.+2      	; 0xc82 <update_lfo+0x3e>
     c80:	bb c0       	rjmp	.+374    	; 0xdf8 <update_lfo+0x1b4>
     c82:	aa c0       	rjmp	.+340    	; 0xdd8 <update_lfo+0x194>
  {
    case 0: // triangle
      lfoval = (lfotimer*lfodelta) >> 8;
     c84:	30 e0       	ldi	r19, 0x00	; 0
     c86:	26 9f       	mul	r18, r22
     c88:	c0 01       	movw	r24, r0
     c8a:	27 9f       	mul	r18, r23
     c8c:	90 0d       	add	r25, r0
     c8e:	36 9f       	mul	r19, r22
     c90:	90 0d       	add	r25, r0
     c92:	11 24       	eor	r1, r1
     c94:	49 2f       	mov	r20, r25
     c96:	55 27       	eor	r21, r21
     c98:	50 93 68 01 	sts	0x0168, r21
     c9c:	40 93 67 01 	sts	0x0167, r20
      if (lfotimer >= lfofreq/2)
     ca0:	80 91 59 01 	lds	r24, 0x0159
     ca4:	90 91 5a 01 	lds	r25, 0x015A
     ca8:	96 95       	lsr	r25
     caa:	87 95       	ror	r24
     cac:	28 17       	cp	r18, r24
     cae:	39 07       	cpc	r19, r25
     cb0:	08 f4       	brcc	.+2      	; 0xcb4 <update_lfo+0x70>
     cb2:	a2 c0       	rjmp	.+324    	; 0xdf8 <update_lfo+0x1b4>
        lfoval = lfodepth - lfoval;
     cb4:	80 91 5b 01 	lds	r24, 0x015B
     cb8:	90 91 5c 01 	lds	r25, 0x015C
     cbc:	84 1b       	sub	r24, r20
     cbe:	95 0b       	sbc	r25, r21
     cc0:	97 c0       	rjmp	.+302    	; 0xdf0 <update_lfo+0x1ac>
      break;
    case 1: // sawtooth up
      lfoval = (lfotimer*lfodelta) >> 8;
     cc2:	80 91 66 01 	lds	r24, 0x0166
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	20 91 69 01 	lds	r18, 0x0169
     ccc:	30 91 6a 01 	lds	r19, 0x016A
     cd0:	ac 01       	movw	r20, r24
     cd2:	42 9f       	mul	r20, r18
     cd4:	c0 01       	movw	r24, r0
     cd6:	43 9f       	mul	r20, r19
     cd8:	90 0d       	add	r25, r0
     cda:	52 9f       	mul	r21, r18
     cdc:	90 0d       	add	r25, r0
     cde:	11 24       	eor	r1, r1
     ce0:	90 93 67 01 	sts	0x0167, r25
     ce4:	10 92 68 01 	sts	0x0168, r1
     ce8:	87 c0       	rjmp	.+270    	; 0xdf8 <update_lfo+0x1b4>
      break;
    case 2: // sawtooth down
      lfoval = lfodepth - ((lfotimer*lfodelta) >> 8);
     cea:	82 2f       	mov	r24, r18
     cec:	90 e0       	ldi	r25, 0x00	; 0
     cee:	86 9f       	mul	r24, r22
     cf0:	90 01       	movw	r18, r0
     cf2:	87 9f       	mul	r24, r23
     cf4:	30 0d       	add	r19, r0
     cf6:	96 9f       	mul	r25, r22
     cf8:	30 0d       	add	r19, r0
     cfa:	11 24       	eor	r1, r1
     cfc:	23 2f       	mov	r18, r19
     cfe:	33 27       	eor	r19, r19
     d00:	5f c0       	rjmp	.+190    	; 0xdc0 <update_lfo+0x17c>
      break;
    case 3: // square
      lfoval = (lfotimer >= lfofreq/2) ? lfodepth : 0;
     d02:	20 91 66 01 	lds	r18, 0x0166
     d06:	30 e0       	ldi	r19, 0x00	; 0
     d08:	80 91 59 01 	lds	r24, 0x0159
     d0c:	90 91 5a 01 	lds	r25, 0x015A
     d10:	96 95       	lsr	r25
     d12:	87 95       	ror	r24
     d14:	28 17       	cp	r18, r24
     d16:	39 07       	cpc	r19, r25
     d18:	90 f4       	brcc	.+36     	; 0xd3e <update_lfo+0xfa>
     d1a:	0e c0       	rjmp	.+28     	; 0xd38 <update_lfo+0xf4>
      break;
    case 4: // half square
      lfoval = (lfotimer < lfofreq/4) ? lfodepth : 0;
     d1c:	20 91 66 01 	lds	r18, 0x0166
     d20:	30 e0       	ldi	r19, 0x00	; 0
     d22:	80 91 59 01 	lds	r24, 0x0159
     d26:	90 91 5a 01 	lds	r25, 0x015A
     d2a:	96 95       	lsr	r25
     d2c:	87 95       	ror	r24
     d2e:	96 95       	lsr	r25
     d30:	87 95       	ror	r24
     d32:	28 17       	cp	r18, r24
     d34:	39 07       	cpc	r19, r25
     d36:	18 f0       	brcs	.+6      	; 0xd3e <update_lfo+0xfa>
     d38:	80 e0       	ldi	r24, 0x00	; 0
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	59 c0       	rjmp	.+178    	; 0xdf0 <update_lfo+0x1ac>
     d3e:	80 91 5b 01 	lds	r24, 0x015B
     d42:	90 91 5c 01 	lds	r25, 0x015C
     d46:	54 c0       	rjmp	.+168    	; 0xdf0 <update_lfo+0x1ac>
      break;
    case 5: // half sawtooth up
      if (lfotimer < lfofreq/2)
     d48:	80 91 66 01 	lds	r24, 0x0166
     d4c:	28 2f       	mov	r18, r24
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	80 91 59 01 	lds	r24, 0x0159
     d54:	90 91 5a 01 	lds	r25, 0x015A
     d58:	96 95       	lsr	r25
     d5a:	87 95       	ror	r24
     d5c:	28 17       	cp	r18, r24
     d5e:	39 07       	cpc	r19, r25
     d60:	b0 f5       	brcc	.+108    	; 0xdce <update_lfo+0x18a>
        lfoval = (lfotimer*lfodelta) >> 7;
     d62:	80 91 69 01 	lds	r24, 0x0169
     d66:	90 91 6a 01 	lds	r25, 0x016A
     d6a:	ac 01       	movw	r20, r24
     d6c:	24 9f       	mul	r18, r20
     d6e:	c0 01       	movw	r24, r0
     d70:	25 9f       	mul	r18, r21
     d72:	90 0d       	add	r25, r0
     d74:	34 9f       	mul	r19, r20
     d76:	90 0d       	add	r25, r0
     d78:	11 24       	eor	r1, r1
     d7a:	88 0f       	add	r24, r24
     d7c:	89 2f       	mov	r24, r25
     d7e:	88 1f       	adc	r24, r24
     d80:	99 0b       	sbc	r25, r25
     d82:	91 95       	neg	r25
     d84:	35 c0       	rjmp	.+106    	; 0xdf0 <update_lfo+0x1ac>
      else
        lfoval = 0;
      break;
    case 6: // half sawtooth down
      if (lfotimer < lfofreq/2)
     d86:	80 91 66 01 	lds	r24, 0x0166
     d8a:	48 2f       	mov	r20, r24
     d8c:	50 e0       	ldi	r21, 0x00	; 0
     d8e:	80 91 59 01 	lds	r24, 0x0159
     d92:	90 91 5a 01 	lds	r25, 0x015A
     d96:	96 95       	lsr	r25
     d98:	87 95       	ror	r24
     d9a:	48 17       	cp	r20, r24
     d9c:	59 07       	cpc	r21, r25
     d9e:	b8 f4       	brcc	.+46     	; 0xdce <update_lfo+0x18a>
        lfoval = lfodepth - ((lfotimer*lfodelta) >> 7);
     da0:	80 91 69 01 	lds	r24, 0x0169
     da4:	90 91 6a 01 	lds	r25, 0x016A
     da8:	48 9f       	mul	r20, r24
     daa:	90 01       	movw	r18, r0
     dac:	49 9f       	mul	r20, r25
     dae:	30 0d       	add	r19, r0
     db0:	58 9f       	mul	r21, r24
     db2:	30 0d       	add	r19, r0
     db4:	11 24       	eor	r1, r1
     db6:	22 0f       	add	r18, r18
     db8:	23 2f       	mov	r18, r19
     dba:	22 1f       	adc	r18, r18
     dbc:	33 0b       	sbc	r19, r19
     dbe:	31 95       	neg	r19
     dc0:	80 91 5b 01 	lds	r24, 0x015B
     dc4:	90 91 5c 01 	lds	r25, 0x015C
     dc8:	82 1b       	sub	r24, r18
     dca:	93 0b       	sbc	r25, r19
     dcc:	11 c0       	rjmp	.+34     	; 0xdf0 <update_lfo+0x1ac>
      else
        lfoval = 0;
     dce:	10 92 68 01 	sts	0x0168, r1
     dd2:	10 92 67 01 	sts	0x0167, r1
     dd6:	10 c0       	rjmp	.+32     	; 0xdf8 <update_lfo+0x1b4>
      break;
    case 7: // random
      if (lfotimer == 0)
     dd8:	80 91 66 01 	lds	r24, 0x0166
     ddc:	88 23       	and	r24, r24
     dde:	61 f4       	brne	.+24     	; 0xdf8 <update_lfo+0x1b4>
        lfoval = lfsr_rand() % lfodepth;
     de0:	0e 94 bc 04 	call	0x978	; 0x978 <lfsr_rand>
     de4:	60 91 5b 01 	lds	r22, 0x015B
     de8:	70 91 5c 01 	lds	r23, 0x015C
     dec:	0e 94 1a 09 	call	0x1234	; 0x1234 <__udivmodhi4>
     df0:	90 93 68 01 	sts	0x0168, r25
     df4:	80 93 67 01 	sts	0x0167, r24
  if (lfotimer < lfofreq/2)
   ;//set_bit(PORT(LEDS), LFO_LED_PIN);
  else
    ;//clear_bit(PORT(LEDS), LFO_LED_PIN);

  lfotimer++;
     df8:	80 91 66 01 	lds	r24, 0x0166
     dfc:	8f 5f       	subi	r24, 0xFF	; 255
     dfe:	80 93 66 01 	sts	0x0166, r24
  if (lfotimer >= lfofreq)
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	20 91 59 01 	lds	r18, 0x0159
     e08:	30 91 5a 01 	lds	r19, 0x015A
     e0c:	82 17       	cp	r24, r18
     e0e:	93 07       	cpc	r25, r19
     e10:	10 f0       	brcs	.+4      	; 0xe16 <update_lfo+0x1d2>
    lfotimer = 0;
     e12:	10 92 66 01 	sts	0x0166, r1
     e16:	08 95       	ret

00000e18 <update_env>:

// update envelope state
void update_env()
{
  // increment envelope timer and wrap around
  envtimer++;
     e18:	80 91 6b 01 	lds	r24, 0x016B
     e1c:	8f 5f       	subi	r24, 0xFF	; 255
     e1e:	80 93 6b 01 	sts	0x016B, r24
  if (envtimer >= envfreq)
     e22:	90 91 5d 01 	lds	r25, 0x015D
     e26:	89 17       	cp	r24, r25
     e28:	10 f0       	brcs	.+4      	; 0xe2e <update_env+0x16>
    envtimer = 0;
     e2a:	10 92 6b 01 	sts	0x016B, r1

  // determine output value
  envval = (envtimer <= envwidth);
     e2e:	20 e0       	ldi	r18, 0x00	; 0
     e30:	90 91 6b 01 	lds	r25, 0x016B
     e34:	80 91 5e 01 	lds	r24, 0x015E
     e38:	89 17       	cp	r24, r25
     e3a:	08 f0       	brcs	.+2      	; 0xe3e <update_env+0x26>
     e3c:	21 e0       	ldi	r18, 0x01	; 1
     e3e:	20 93 0c 01 	sts	0x010C, r18
  if (envval)
     e42:	80 91 0c 01 	lds	r24, 0x010C
    ;//set_bit(PORT(LEDS),ENV_LED_PIN);
  else
    ;//clear_bit(PORT(LEDS),ENV_LED_PIN);
}
     e46:	08 95       	ret

00000e48 <update_synth_params>:

// update parameters based on knob values
void update_synth_params()
{
  // disregard pitch if midi enabled
  if (!usemidi)
     e48:	80 91 60 01 	lds	r24, 0x0160
     e4c:	88 23       	and	r24, r24
     e4e:	41 f4       	brne	.+16     	; 0xe60 <update_synth_params+0x18>
    pitch = knobs[PITCH_KNOB].val;
     e50:	80 91 3b 01 	lds	r24, 0x013B
     e54:	90 91 3c 01 	lds	r25, 0x013C
     e58:	90 93 09 01 	sts	0x0109, r25
     e5c:	80 93 08 01 	sts	0x0108, r24
  
  uint8_t newwavenum = knobs[AUDIO_WF_KNOB].val >> 7;
     e60:	20 91 47 01 	lds	r18, 0x0147
     e64:	30 91 48 01 	lds	r19, 0x0148
     e68:	22 0f       	add	r18, r18
     e6a:	23 2f       	mov	r18, r19
     e6c:	22 1f       	adc	r18, r18
     e6e:	33 0b       	sbc	r19, r19
     e70:	31 95       	neg	r19
  if (newwavenum != wavenum)
     e72:	80 91 5f 01 	lds	r24, 0x015F
     e76:	82 17       	cp	r24, r18
     e78:	91 f0       	breq	.+36     	; 0xe9e <update_synth_params+0x56>
  {
    wavenum = newwavenum;
     e7a:	20 93 5f 01 	sts	0x015F, r18
    waveform = waveforms[wavenum];
     e7e:	e0 91 5f 01 	lds	r30, 0x015F
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	ee 0f       	add	r30, r30
     e86:	ff 1f       	adc	r31, r31
     e88:	e3 5f       	subi	r30, 0xF3	; 243
     e8a:	fe 4f       	sbci	r31, 0xFE	; 254
     e8c:	80 81       	ld	r24, Z
     e8e:	91 81       	ldd	r25, Z+1	; 0x01
     e90:	90 93 77 01 	sts	0x0177, r25
     e94:	80 93 76 01 	sts	0x0176, r24
    ledpulse = 1;
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	80 93 6c 01 	sts	0x016C, r24
  }

  uint8_t newlfowavenum = knobs[LFO_WF_KNOB].val >> 7;
     e9e:	20 91 23 01 	lds	r18, 0x0123
     ea2:	30 91 24 01 	lds	r19, 0x0124
     ea6:	22 0f       	add	r18, r18
     ea8:	23 2f       	mov	r18, r19
     eaa:	22 1f       	adc	r18, r18
     eac:	33 0b       	sbc	r19, r19
     eae:	31 95       	neg	r19
  if (newlfowavenum != lfowavenum)
     eb0:	80 91 0a 01 	lds	r24, 0x010A
     eb4:	82 17       	cp	r24, r18
     eb6:	29 f0       	breq	.+10     	; 0xec2 <update_synth_params+0x7a>
  {
    lfowavenum = newlfowavenum;
     eb8:	20 93 0a 01 	sts	0x010A, r18
    ledpulse = 1;
     ebc:	81 e0       	ldi	r24, 0x01	; 1
     ebe:	80 93 6c 01 	sts	0x016C, r24
  }

  // pulse the power LED to indicate waveform changes
  if (ledpulse)
     ec2:	80 91 6c 01 	lds	r24, 0x016C
     ec6:	88 23       	and	r24, r24
     ec8:	19 f0       	breq	.+6      	; 0xed0 <update_synth_params+0x88>
  {
    ;//clear_bit(PORT(LEDS), PWR_LED_PIN);
    ledpulse--;
     eca:	81 50       	subi	r24, 0x01	; 1
     ecc:	80 93 6c 01 	sts	0x016C, r24
  }
  else
    ;//set_bit(PORT(LEDS), PWR_LED_PIN);    
  
  lfofreq = knobs[LFO_FREQ_KNOB].val >> 2;
     ed0:	60 91 35 01 	lds	r22, 0x0135
     ed4:	70 91 36 01 	lds	r23, 0x0136
     ed8:	76 95       	lsr	r23
     eda:	67 95       	ror	r22
     edc:	76 95       	lsr	r23
     ede:	67 95       	ror	r22
     ee0:	70 93 5a 01 	sts	0x015A, r23
     ee4:	60 93 59 01 	sts	0x0159, r22
  lfodepth = knobs[LFO_DEPTH_KNOB].val >> 2;
     ee8:	20 91 2f 01 	lds	r18, 0x012F
     eec:	30 91 30 01 	lds	r19, 0x0130
     ef0:	36 95       	lsr	r19
     ef2:	27 95       	ror	r18
     ef4:	36 95       	lsr	r19
     ef6:	27 95       	ror	r18
     ef8:	30 93 5c 01 	sts	0x015C, r19
     efc:	20 93 5b 01 	sts	0x015B, r18
  lfodelta = (lfofreq) ? (lfodepth*256U) / lfofreq : 0;
     f00:	61 15       	cp	r22, r1
     f02:	71 05       	cpc	r23, r1
     f04:	19 f4       	brne	.+6      	; 0xf0c <update_synth_params+0xc4>
     f06:	80 e0       	ldi	r24, 0x00	; 0
     f08:	90 e0       	ldi	r25, 0x00	; 0
     f0a:	05 c0       	rjmp	.+10     	; 0xf16 <update_synth_params+0xce>
     f0c:	80 e0       	ldi	r24, 0x00	; 0
     f0e:	92 2f       	mov	r25, r18
     f10:	0e 94 1a 09 	call	0x1234	; 0x1234 <__udivmodhi4>
     f14:	cb 01       	movw	r24, r22
     f16:	90 93 6a 01 	sts	0x016A, r25
     f1a:	80 93 69 01 	sts	0x0169, r24
  
  envfreq = knobs[ENV_FREQ_KNOB].val >> 2;
     f1e:	80 91 41 01 	lds	r24, 0x0141
     f22:	90 91 42 01 	lds	r25, 0x0142
     f26:	96 95       	lsr	r25
     f28:	87 95       	ror	r24
     f2a:	96 95       	lsr	r25
     f2c:	87 95       	ror	r24
     f2e:	80 93 5d 01 	sts	0x015D, r24
  envwidth = knobs[ENV_WIDTH_KNOB].val >> 2;
     f32:	80 91 29 01 	lds	r24, 0x0129
     f36:	90 91 2a 01 	lds	r25, 0x012A
     f3a:	96 95       	lsr	r25
     f3c:	87 95       	ror	r24
     f3e:	96 95       	lsr	r25
     f40:	87 95       	ror	r24
     f42:	80 93 5e 01 	sts	0x015E, r24
}
     f46:	08 95       	ret

00000f48 <SetRC>:


// Write to LED Array - Takes in a Row and Column
// this routine is written to help understand how the process works, not fast.
void SetRC( unsigned char R, unsigned char C ) 
{	
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
	unsigned char b1,b2;
	unsigned char port_a, ddr_a;

	if ( C  > 4  ) C = 0;
     f50:	65 30       	cpi	r22, 0x05	; 5
     f52:	08 f0       	brcs	.+2      	; 0xf56 <SetRC+0xe>
     f54:	60 e0       	ldi	r22, 0x00	; 0
	if ( R  > 5  ) R = 0;
     f56:	86 30       	cpi	r24, 0x06	; 6
     f58:	08 f0       	brcs	.+2      	; 0xf5c <SetRC+0x14>
     f5a:	80 e0       	ldi	r24, 0x00	; 0

	// get current values, Can't cache PORTA/DDRA since the sound interrupt can change, 
	// should cache DDRD6/PORTD6 instead
	port_a = PORTA;
     f5c:	2b b3       	in	r18, 0x1b	; 27
	ddr_a = DDRA;
     f5e:	3a b3       	in	r19, 0x1a	; 26

	//	read two values from array, we use pgm_read_byte because the data is in program memory space
	// its 4*2 because there are 4 leds in each column, and two bytes per led
	b1 = pgm_read_byte(&led30[ (R*(4*2))+(C*2)   ] ) ;
     f60:	a8 2f       	mov	r26, r24
     f62:	b0 e0       	ldi	r27, 0x00	; 0
     f64:	aa 0f       	add	r26, r26
     f66:	bb 1f       	adc	r27, r27
     f68:	aa 0f       	add	r26, r26
     f6a:	bb 1f       	adc	r27, r27
     f6c:	a6 0f       	add	r26, r22
     f6e:	b1 1d       	adc	r27, r1
     f70:	aa 0f       	add	r26, r26
     f72:	bb 1f       	adc	r27, r27
     f74:	cd 01       	movw	r24, r26
     f76:	8e 5e       	subi	r24, 0xEE	; 238
     f78:	96 4f       	sbci	r25, 0xF6	; 246
     f7a:	fc 01       	movw	r30, r24
     f7c:	44 91       	lpm	r20, Z+
	b2 = pgm_read_byte(&led30[((R*(4*2))+(C*2))+1] ) ;
     f7e:	ad 5e       	subi	r26, 0xED	; 237
     f80:	b6 4f       	sbci	r27, 0xF6	; 246
     f82:	fd 01       	movw	r30, r26
     f84:	54 91       	lpm	r21, Z+

	//	b1 = led30[ (R*(4*2))+(C*2)   ]  ;
	//	b2 = led30[((R*(4*2))+(C*2))+1];
	
	// if 10 == 11 then set to don't care (input ) tristate for PB0
	if( GET_BIT( b1,1 )==1 && GET_BIT( b1,0 )==1 ) {
     f86:	84 2f       	mov	r24, r20
     f88:	86 95       	lsr	r24
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	8c 01       	movw	r16, r24
     f8e:	01 70       	andi	r16, 0x01	; 1
     f90:	10 70       	andi	r17, 0x00	; 0
     f92:	80 ff       	sbrs	r24, 0
     f94:	05 c0       	rjmp	.+10     	; 0xfa0 <SetRC+0x58>
     f96:	40 ff       	sbrs	r20, 0
     f98:	03 c0       	rjmp	.+6      	; 0xfa0 <SetRC+0x58>

		CLR_BIT(ddr_a,2 );
     f9a:	93 2f       	mov	r25, r19
     f9c:	9b 7f       	andi	r25, 0xFB	; 251
     f9e:	02 c0       	rjmp	.+4      	; 0xfa4 <SetRC+0x5c>

	} else { 

		// otherwise its an output
		SET_BIT(ddr_a ,2 );
     fa0:	93 2f       	mov	r25, r19
     fa2:	94 60       	ori	r25, 0x04	; 4
	}

	// if 76 == 11 then set to don't care (input ) tristate  for PB1
	if( GET_BIT( b2,7 )==1 && GET_BIT( b2,6 )==1 ) {
     fa4:	57 ff       	sbrs	r21, 7
     fa6:	0a c0       	rjmp	.+20     	; 0xfbc <SetRC+0x74>
     fa8:	85 2f       	mov	r24, r21
     faa:	82 95       	swap	r24
     fac:	86 95       	lsr	r24
     fae:	86 95       	lsr	r24
     fb0:	83 70       	andi	r24, 0x03	; 3
     fb2:	80 ff       	sbrs	r24, 0
     fb4:	03 c0       	rjmp	.+6      	; 0xfbc <SetRC+0x74>

		CLR_BIT(ddr_a,1 );
     fb6:	39 2f       	mov	r19, r25
     fb8:	3d 7f       	andi	r19, 0xFD	; 253
     fba:	02 c0       	rjmp	.+4      	; 0xfc0 <SetRC+0x78>

	} else { 

		// otherwise its an output
		SET_BIT(ddr_a ,1 );
     fbc:	39 2f       	mov	r19, r25
     fbe:	32 60       	ori	r19, 0x02	; 2
	}

	// if 54 == 11 then set to don't care (input ) tristate for PB2
	if( GET_BIT( b2,5 )==1 && GET_BIT( b2,4 )==1 ) {
     fc0:	85 2f       	mov	r24, r21
     fc2:	82 95       	swap	r24
     fc4:	86 95       	lsr	r24
     fc6:	87 70       	andi	r24, 0x07	; 7
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	ec 01       	movw	r28, r24
     fcc:	c1 70       	andi	r28, 0x01	; 1
     fce:	d0 70       	andi	r29, 0x00	; 0
     fd0:	80 ff       	sbrs	r24, 0
     fd2:	07 c0       	rjmp	.+14     	; 0xfe2 <SetRC+0x9a>
     fd4:	85 2f       	mov	r24, r21
     fd6:	82 95       	swap	r24
     fd8:	8f 70       	andi	r24, 0x0F	; 15
     fda:	80 ff       	sbrs	r24, 0
     fdc:	02 c0       	rjmp	.+4      	; 0xfe2 <SetRC+0x9a>

		CLR_BIT(ddr_a,0 );
     fde:	3e 7f       	andi	r19, 0xFE	; 254
     fe0:	01 c0       	rjmp	.+2      	; 0xfe4 <SetRC+0x9c>

	} else { 

		// otherwise its an output
		SET_BIT(ddr_a ,0 );
     fe2:	31 60       	ori	r19, 0x01	; 1
	}

	// if 32 == 11 then set to don't care (input ) tristate for PB3
	if( GET_BIT( b2,3 )==1 && GET_BIT( b2,2 )==1 ) {
     fe4:	85 2f       	mov	r24, r21
     fe6:	86 95       	lsr	r24
     fe8:	86 95       	lsr	r24
     fea:	86 95       	lsr	r24
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	dc 01       	movw	r26, r24
     ff0:	a1 70       	andi	r26, 0x01	; 1
     ff2:	b0 70       	andi	r27, 0x00	; 0
     ff4:	80 ff       	sbrs	r24, 0
     ff6:	07 c0       	rjmp	.+14     	; 0x1006 <SetRC+0xbe>
     ff8:	85 2f       	mov	r24, r21
     ffa:	86 95       	lsr	r24
     ffc:	86 95       	lsr	r24
     ffe:	80 ff       	sbrs	r24, 0
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <SetRC+0xbe>

		CLR_BIT(ddr_a,4 );
    1002:	3f 7e       	andi	r19, 0xEF	; 239
    1004:	01 c0       	rjmp	.+2      	; 0x1008 <SetRC+0xc0>

	} else { 

		// otherwise its an output
		SET_BIT(ddr_a ,4 );
    1006:	30 61       	ori	r19, 0x10	; 16
	}

	// if 10 == 11 then set to don't care (input ) tristate for PB4
	if( GET_BIT( b2,1 )==1 && GET_BIT( b2,0 )==1 ) {
    1008:	85 2f       	mov	r24, r21
    100a:	86 95       	lsr	r24
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	bc 01       	movw	r22, r24
    1010:	61 70       	andi	r22, 0x01	; 1
    1012:	70 70       	andi	r23, 0x00	; 0
    1014:	80 ff       	sbrs	r24, 0
    1016:	05 c0       	rjmp	.+10     	; 0x1022 <SetRC+0xda>
    1018:	50 ff       	sbrs	r21, 0
    101a:	03 c0       	rjmp	.+6      	; 0x1022 <SetRC+0xda>

		CLR_BIT(ddr_a,3 );
    101c:	93 2f       	mov	r25, r19
    101e:	97 7f       	andi	r25, 0xF7	; 247
    1020:	02 c0       	rjmp	.+4      	; 0x1026 <SetRC+0xde>

	} else { 

		// otherwise its an output
		SET_BIT(ddr_a ,3 );
    1022:	93 2f       	mov	r25, r19
    1024:	98 60       	ori	r25, 0x08	; 8

	/// all of the DDR's are set


	// if 10 == 00 then set to low for PB0
	if( GET_BIT( b1,1 )==0 && GET_BIT( b1,0 )==0 ) {
    1026:	01 2b       	or	r16, r17
    1028:	29 f4       	brne	.+10     	; 0x1034 <SetRC+0xec>
    102a:	40 fd       	sbrc	r20, 0
    102c:	02 c0       	rjmp	.+4      	; 0x1032 <SetRC+0xea>

		CLR_BIT(port_a,2); //set to off
    102e:	2b 7f       	andi	r18, 0xFB	; 251
    1030:	01 c0       	rjmp	.+2      	; 0x1034 <SetRC+0xec>

	// if 32 == 01 then set to high for PB0
	} else if( GET_BIT( b1,1 )==0 && GET_BIT( b1,0 )==1 ) { 

		// set to on
		SET_BIT(port_a ,2 );
    1032:	24 60       	ori	r18, 0x04	; 4
	}

	// if 76 == 00 then set to low for PB1
	if( GET_BIT( b2,7 )==0 && GET_BIT( b2,6 )==0 ) {
    1034:	57 fd       	sbrc	r21, 7
    1036:	0a c0       	rjmp	.+20     	; 0x104c <SetRC+0x104>
    1038:	85 2f       	mov	r24, r21
    103a:	82 95       	swap	r24
    103c:	86 95       	lsr	r24
    103e:	86 95       	lsr	r24
    1040:	83 70       	andi	r24, 0x03	; 3
    1042:	80 fd       	sbrc	r24, 0
    1044:	02 c0       	rjmp	.+4      	; 0x104a <SetRC+0x102>

		CLR_BIT(port_a,1); //set to off
    1046:	2d 7f       	andi	r18, 0xFD	; 253
    1048:	01 c0       	rjmp	.+2      	; 0x104c <SetRC+0x104>

	// if 32 == 01 then set to high for PB1
	} else if( GET_BIT( b2,7 )==0 && GET_BIT( b2,6 ) ==1 ) { 

		// set to on
		SET_BIT(port_a ,1 );
    104a:	22 60       	ori	r18, 0x02	; 2
	}


	// if 54 == 00 then set to low for PB2
	if( GET_BIT( b2,5 )==0 && GET_BIT( b2,4 )==0 ) {
    104c:	cd 2b       	or	r28, r29
    104e:	41 f4       	brne	.+16     	; 0x1060 <SetRC+0x118>
    1050:	85 2f       	mov	r24, r21
    1052:	82 95       	swap	r24
    1054:	8f 70       	andi	r24, 0x0F	; 15
    1056:	80 fd       	sbrc	r24, 0
    1058:	02 c0       	rjmp	.+4      	; 0x105e <SetRC+0x116>

		CLR_BIT(port_a,0); //set to off
    105a:	2e 7f       	andi	r18, 0xFE	; 254
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <SetRC+0x118>

	// if 32 == 01 then set to high for PB2
	} else if( GET_BIT( b2,5 )==0 && GET_BIT( b2,4 )==1 ) { 

		// set to on
		SET_BIT(port_a ,0 );
    105e:	21 60       	ori	r18, 0x01	; 1
	}

	// if 32 == 00 then set to low for PB3
	if( GET_BIT( b2,3 )==0 && GET_BIT( b2,2 )==0 ) {
    1060:	ab 2b       	or	r26, r27
    1062:	41 f4       	brne	.+16     	; 0x1074 <SetRC+0x12c>
    1064:	85 2f       	mov	r24, r21
    1066:	86 95       	lsr	r24
    1068:	86 95       	lsr	r24
    106a:	80 fd       	sbrc	r24, 0
    106c:	02 c0       	rjmp	.+4      	; 0x1072 <SetRC+0x12a>

		CLR_BIT(port_a,4); //set to off
    106e:	2f 7e       	andi	r18, 0xEF	; 239
    1070:	01 c0       	rjmp	.+2      	; 0x1074 <SetRC+0x12c>

	// if 32 == 01 then set to high for PB3
	} else if( GET_BIT( b2,3 ) ==0 && GET_BIT( b2,2 )==1 ) { 

		// set to on
		SET_BIT(port_a ,4 );
    1072:	20 61       	ori	r18, 0x10	; 16
	}

	// if 10 == 00 then set to low for PB4
	if( GET_BIT( b2,1 )==0 && GET_BIT( b2,0 )==0 ) {
    1074:	67 2b       	or	r22, r23
    1076:	29 f4       	brne	.+10     	; 0x1082 <SetRC+0x13a>
    1078:	50 fd       	sbrc	r21, 0
    107a:	02 c0       	rjmp	.+4      	; 0x1080 <SetRC+0x138>

		CLR_BIT(port_a,3); //set to off
    107c:	27 7f       	andi	r18, 0xF7	; 247
    107e:	01 c0       	rjmp	.+2      	; 0x1082 <SetRC+0x13a>

	// if 32 == 01 then set to high for PB4
	} else if( GET_BIT( b2,1)==0 && GET_BIT( b2,0 )==1 ) { 

		// set to on
		SET_BIT(port_a ,3 );
    1080:	28 60       	ori	r18, 0x08	; 8
	}

	//set all at once.
	PORTA = port_a;
    1082:	2b bb       	out	0x1b, r18	; 27
	DDRA = ddr_a;
    1084:	9a bb       	out	0x1a, r25	; 26
}
    1086:	df 91       	pop	r29
    1088:	cf 91       	pop	r28
    108a:	1f 91       	pop	r17
    108c:	0f 91       	pop	r16
    108e:	08 95       	ret

00001090 <scrollLEDS>:

void scrollLEDS(void)
{
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
	static int c = 0;
	static int r = 0;

	static unsigned short count = 0;

	count ++ ;
    1098:	80 91 6d 01 	lds	r24, 0x016D
    109c:	90 91 6e 01 	lds	r25, 0x016E
    10a0:	01 96       	adiw	r24, 0x01	; 1
    10a2:	90 93 6e 01 	sts	0x016E, r25
    10a6:	80 93 6d 01 	sts	0x016D, r24

	if ( count < 10  ) return;
    10aa:	0a 97       	sbiw	r24, 0x0a	; 10
    10ac:	60 f1       	brcs	.+88     	; 0x1106 <__stack+0x7>

	count = 0;
    10ae:	10 92 6e 01 	sts	0x016E, r1
    10b2:	10 92 6d 01 	sts	0x016D, r1

	SetRC(r,c);
    10b6:	00 91 6f 01 	lds	r16, 0x016F
    10ba:	10 91 70 01 	lds	r17, 0x0170
    10be:	c0 91 71 01 	lds	r28, 0x0171
    10c2:	d0 91 72 01 	lds	r29, 0x0172
    10c6:	80 2f       	mov	r24, r16
    10c8:	6c 2f       	mov	r22, r28
    10ca:	0e 94 a4 07 	call	0xf48	; 0xf48 <SetRC>

	r++ ;
    10ce:	0f 5f       	subi	r16, 0xFF	; 255
    10d0:	1f 4f       	sbci	r17, 0xFF	; 255
    10d2:	10 93 70 01 	sts	0x0170, r17
    10d6:	00 93 6f 01 	sts	0x016F, r16

	if ( r == 5 )  {
    10da:	05 30       	cpi	r16, 0x05	; 5
    10dc:	11 05       	cpc	r17, r1
    10de:	49 f4       	brne	.+18     	; 0x10f2 <scrollLEDS+0x62>
		r = 0;
    10e0:	10 92 70 01 	sts	0x0170, r1
    10e4:	10 92 6f 01 	sts	0x016F, r1
		c++ ;
    10e8:	21 96       	adiw	r28, 0x01	; 1
    10ea:	d0 93 72 01 	sts	0x0172, r29
    10ee:	c0 93 71 01 	sts	0x0171, r28
	}

	if ( c == 4 ) { 
    10f2:	80 91 71 01 	lds	r24, 0x0171
    10f6:	90 91 72 01 	lds	r25, 0x0172
    10fa:	04 97       	sbiw	r24, 0x04	; 4
    10fc:	21 f4       	brne	.+8      	; 0x1106 <__stack+0x7>
		c = 0;
    10fe:	10 92 72 01 	sts	0x0172, r1
    1102:	10 92 71 01 	sts	0x0171, r1
	}
	 
}
    1106:	df 91       	pop	r29
    1108:	cf 91       	pop	r28
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	08 95       	ret

00001110 <main>:
  envfreq = knobs[ENV_FREQ_KNOB].val >> 2;
  envwidth = knobs[ENV_WIDTH_KNOB].val >> 2;
}

int main(void)
{
    1110:	ef 92       	push	r14
    1112:	ff 92       	push	r15
    1114:	1f 93       	push	r17
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
  // enable outputs
  DDR(AUDIO) |= _BV(AUDIO_PIN);
    111a:	a0 9a       	sbi	0x14, 0	; 20
  DDR(LEDS)  |= _BV(ENV_LED_PIN) | _BV(LFO_LED_PIN) | _BV(PWR_LED_PIN);
    111c:	8a b3       	in	r24, 0x1a	; 26
    111e:	8c 61       	ori	r24, 0x1C	; 28
    1120:	8a bb       	out	0x1a, r24	; 26
  DDR(MUXCTL) |= _BV(MUXCTL_PIN);
    1122:	8d 9a       	sbi	0x11, 5	; 17

  DDRC  = 0xff;
    1124:	8f ef       	ldi	r24, 0xFF	; 255
    1126:	84 bb       	out	0x14, r24	; 20
  // turn on power LED
  ;//set_bit(PORT(LEDS), PWR_LED_PIN);

  // set up main oscillator
  TCCR1B |= _BV(WGM12);  // enable CTC
    1128:	8e b5       	in	r24, 0x2e	; 46
    112a:	88 60       	ori	r24, 0x08	; 8
    112c:	8e bd       	out	0x2e, r24	; 46
  TIMSK |= _BV(OCIE1A); // enable CTC interrupt
    112e:	87 b7       	in	r24, 0x37	; 55
    1130:	80 61       	ori	r24, 0x10	; 16
    1132:	87 bf       	out	0x37, r24	; 55

  // set up ADC
  ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0); // 1/128 prescaler
    1134:	86 b1       	in	r24, 0x06	; 6
    1136:	87 60       	ori	r24, 0x07	; 7
    1138:	86 b9       	out	0x06, r24	; 6
  ADCSRA |= _BV(ADEN); // enable ADC
    113a:	37 9a       	sbi	0x06, 7	; 6

  // set up midi
  midi_init();
    113c:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <midi_init>

  sei(); // enable interrupts
    1140:	78 94       	sei
 
  lfowavenum = 0;
    1142:	10 92 0a 01 	sts	0x010A, r1
  wavenum = 0;
    1146:	10 92 5f 01 	sts	0x015F, r1
  waveform = waveforms[wavenum];
    114a:	e0 91 5f 01 	lds	r30, 0x015F
    114e:	f0 e0       	ldi	r31, 0x00	; 0
    1150:	ee 0f       	add	r30, r30
    1152:	ff 1f       	adc	r31, r31
    1154:	e3 5f       	subi	r30, 0xF3	; 243
    1156:	fe 4f       	sbci	r31, 0xFE	; 254
    1158:	80 81       	ld	r24, Z
    115a:	91 81       	ldd	r25, Z+1	; 0x01
    115c:	90 93 77 01 	sts	0x0177, r25
    1160:	80 93 76 01 	sts	0x0176, r24

  update_pitch();
    1164:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <update_pitch>
  TCCR1B |= _BV(CS11); // set prescaler to 8; starts oscillator  
    1168:	8e b5       	in	r24, 0x2e	; 46
    116a:	82 60       	ori	r24, 0x02	; 2
    116c:	8e bd       	out	0x2e, r24	; 46

  adctimer = 0;
    116e:	10 92 22 01 	sts	0x0122, r1
			if( daftIndex == sizeof( daft ) ) {
				daftIndex = 0;

			}

			counter = 25;
    1172:	f9 e1       	ldi	r31, 0x19	; 25
    1174:	ef 2e       	mov	r14, r31
    1176:	f1 2c       	mov	r15, r1
  adctimer = 0;
  for (;;)
  {
    uint8_t adcchan = 0;

    adctimer++;
    1178:	80 91 22 01 	lds	r24, 0x0122
    117c:	8f 5f       	subi	r24, 0xFF	; 255
    117e:	80 93 22 01 	sts	0x0122, r24
    adctimer &= (NUM_ADC_SAMPLES-1);
    1182:	80 91 22 01 	lds	r24, 0x0122
    1186:	8f 71       	andi	r24, 0x1F	; 31
    1188:	80 93 22 01 	sts	0x0122, r24

    // select mux channel group 0
    clear_bit(PORT(MUXCTL), MUXCTL_PIN);
    118c:	95 98       	cbi	0x12, 5	; 18
    118e:	c3 e2       	ldi	r28, 0x23	; 35
    1190:	d1 e0       	ldi	r29, 0x01	; 1
    1192:	10 e0       	ldi	r17, 0x00	; 0

    // read ADC channels
    for (adcchan = 0; adcchan < NUM_ADC_CHANNELS; adcchan++)
    {
      ADMUX = _BV(REFS0) | adcchan;
    1194:	81 2f       	mov	r24, r17
    1196:	80 64       	ori	r24, 0x40	; 64
    1198:	87 b9       	out	0x07, r24	; 7
      ADCSRA |= _BV(ADSC);
    119a:	36 9a       	sbi	0x06, 6	; 6
      loop_until_bit_is_clear(ADCSRA, ADSC);
    119c:	36 99       	sbic	0x06, 6	; 6
    119e:	fe cf       	rjmp	.-4      	; 0x119c <main+0x8c>

      read_adc(knobs+adcchan);
    11a0:	ce 01       	movw	r24, r28
    11a2:	0e 94 ca 05 	call	0xb94	; 0xb94 <read_adc>

    // select mux channel group 0
    clear_bit(PORT(MUXCTL), MUXCTL_PIN);

    // read ADC channels
    for (adcchan = 0; adcchan < NUM_ADC_CHANNELS; adcchan++)
    11a6:	1f 5f       	subi	r17, 0xFF	; 255
    11a8:	26 96       	adiw	r28, 0x06	; 6
    11aa:	18 30       	cpi	r17, 0x08	; 8
    11ac:	99 f7       	brne	.-26     	; 0x1194 <main+0x84>
      read_adc(knobs+adcchan);
    }
   
 
    // update values after we've read averaged values from all knobs
    if (adctimer == 0) {
    11ae:	80 91 22 01 	lds	r24, 0x0122
    11b2:	88 23       	and	r24, r24
    11b4:	11 f4       	brne	.+4      	; 0x11ba <main+0xaa>
      update_synth_params();
    11b6:	0e 94 24 07 	call	0xe48	; 0xe48 <update_synth_params>
	}

    update_lfo();
    11ba:	0e 94 22 06 	call	0xc44	; 0xc44 <update_lfo>
    update_env();
    11be:	0e 94 0c 07 	call	0xe18	; 0xe18 <update_env>
    update_pitch();
    11c2:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <update_pitch>

	scrollLEDS();
    11c6:	0e 94 48 08 	call	0x1090	; 0x1090 <scrollLEDS>

#if 1

	if( selfPlay ) 
    11ca:	80 91 06 01 	lds	r24, 0x0106
    11ce:	90 91 07 01 	lds	r25, 0x0107
    11d2:	89 2b       	or	r24, r25
    11d4:	89 f2       	breq	.-94     	; 0x1178 <main+0x68>
	{
		if( counter == 0 ) {
    11d6:	80 91 04 01 	lds	r24, 0x0104
    11da:	90 91 05 01 	lds	r25, 0x0105
    11de:	00 97       	sbiw	r24, 0x00	; 0
    11e0:	19 f5       	brne	.+70     	; 0x1228 <main+0x118>

			processMessage(   pgm_read_byte(&daft[daftIndex]) );
    11e2:	e0 91 73 01 	lds	r30, 0x0173
    11e6:	f0 91 74 01 	lds	r31, 0x0174
    11ea:	e4 57       	subi	r30, 0x74	; 116
    11ec:	fe 4f       	sbci	r31, 0xFE	; 254
    11ee:	e4 91       	lpm	r30, Z+
    11f0:	8e 2f       	mov	r24, r30
    11f2:	0e 94 dd 04 	call	0x9ba	; 0x9ba <processMessage>

			daftIndex ++; 
    11f6:	80 91 73 01 	lds	r24, 0x0173
    11fa:	90 91 74 01 	lds	r25, 0x0174
    11fe:	01 96       	adiw	r24, 0x01	; 1
    1200:	90 93 74 01 	sts	0x0174, r25
    1204:	80 93 73 01 	sts	0x0173, r24

			if( daftIndex == sizeof( daft ) ) {
    1208:	80 91 73 01 	lds	r24, 0x0173
    120c:	90 91 74 01 	lds	r25, 0x0174
    1210:	86 58       	subi	r24, 0x86	; 134
    1212:	97 40       	sbci	r25, 0x07	; 7
    1214:	21 f4       	brne	.+8      	; 0x121e <main+0x10e>
				daftIndex = 0;
    1216:	10 92 74 01 	sts	0x0174, r1
    121a:	10 92 73 01 	sts	0x0173, r1

			}

			counter = 25;
    121e:	f0 92 05 01 	sts	0x0105, r15
    1222:	e0 92 04 01 	sts	0x0104, r14
    1226:	a8 cf       	rjmp	.-176    	; 0x1178 <main+0x68>

		} else {
			counter -- ;
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	90 93 05 01 	sts	0x0105, r25
    122e:	80 93 04 01 	sts	0x0104, r24
    1232:	a2 cf       	rjmp	.-188    	; 0x1178 <main+0x68>

00001234 <__udivmodhi4>:
    1234:	aa 1b       	sub	r26, r26
    1236:	bb 1b       	sub	r27, r27
    1238:	51 e1       	ldi	r21, 0x11	; 17
    123a:	07 c0       	rjmp	.+14     	; 0x124a <__udivmodhi4_ep>

0000123c <__udivmodhi4_loop>:
    123c:	aa 1f       	adc	r26, r26
    123e:	bb 1f       	adc	r27, r27
    1240:	a6 17       	cp	r26, r22
    1242:	b7 07       	cpc	r27, r23
    1244:	10 f0       	brcs	.+4      	; 0x124a <__udivmodhi4_ep>
    1246:	a6 1b       	sub	r26, r22
    1248:	b7 0b       	sbc	r27, r23

0000124a <__udivmodhi4_ep>:
    124a:	88 1f       	adc	r24, r24
    124c:	99 1f       	adc	r25, r25
    124e:	5a 95       	dec	r21
    1250:	a9 f7       	brne	.-22     	; 0x123c <__udivmodhi4_loop>
    1252:	80 95       	com	r24
    1254:	90 95       	com	r25
    1256:	bc 01       	movw	r22, r24
    1258:	cd 01       	movw	r24, r26
    125a:	08 95       	ret

0000125c <_exit>:
    125c:	f8 94       	cli

0000125e <__stop_program>:
    125e:	ff cf       	rjmp	.-2      	; 0x125e <__stop_program>
